## ===============================
## RVFI Input Interface Class
## ===============================
class RVFI_Instr:
    """
    RVFI interface input instruction class
    """
    def __init__(self, pc, inst_op, insn, valid,
                 is_compressed, is_branch, is_taken, ex_valid):
        self.valid = valid                   # æŒ‡ä»¤æœ‰æ•ˆä¿¡å·
        self.pc = pc                         # æŒ‡ä»¤åœ°å€
        self.inst_op = inst_op               # æŒ‡ä»¤ç±»å‹
        self.is_compressed = is_compressed   # æ˜¯å¦å‹ç¼©æŒ‡ä»¤
        self.is_branch = is_branch           # æ˜¯å¦è·³è½¬æŒ‡ä»¤
        self.is_taken = is_taken             # è·³è½¬æ˜¯å¦
        self.ex_valid = ex_valid             # æ˜¯å¦ä¸­æ–­æˆ–å¼‚å¸¸

## ===============================
## Trace Packet Class
## ===============================
class Trace_Pkg:
    """
    Trace packet generated by BETR encoder
    """
    def __init__(self, branch_addr, inst_cnt, br_tkn, extend=0):
        self.Branch_addr = branch_addr  # 32-bit
        self.inst_cnt = inst_cnt        # 10-bit  
        self.Br_tkn = br_tkn            # 32-bit
        self.extend = extend            # 1-bit

    def to_int(self):
        """
        Pack trace packet into single integer (75-bit)
        Format: Branch_addr[31:0] + inst_cnt[9:0] + Br_tkn[31:0] + extend[0]
        """
        return (self.Branch_addr << (10 + 32 + 1)) | (self.inst_cnt << (32 + 1)) | (self.Br_tkn << 1) | self.extend

##@@-- 20251103-Add File system
## ===============================
## Trace Signal File Output (æ–°å¢éƒ¨åˆ†)
## ===============================

class TraceSignalWriter:
    """Traceä¿¡å·æ–‡ä»¶è¾“å‡ºå™¨ - åªä¿å­˜trace_validå’Œtrace_data"""
    
    def __init__(self, filename="trace_signals.txt"):
        self.filename = filename
        
    def save_signal(self, trace_valid, trace_data):
        """ä¿å­˜ä¿¡å·åˆ°æ–‡ä»¶"""
        with open(self.filename, 'a') as f:
            # trace_valid ä¿ç•™ 1 ä½ï¼Œtrace_data è¾“å‡ºå›ºå®š 19 ä½åå…­è¿›åˆ¶
            f.write(f"{trace_valid} {trace_data:019X}\n")

            
##@@-- 20251103-Add File system

## ===============================
## Output Interface Class  
## ===============================
class Trace_Output:
    """
    Simulates BETR encoder output signals
    """
    def __init__(self,trace_filename = None):
        self.trace_valid = 0
        self.trace_data = 0
        self.irq = 0
        
        ##@@-- 20251103-Add File system
        self.file_writer = None
        if trace_filename:
            self.file_writer = TraceSignalWriter(trace_filename)
            # å†™å…¥æ–‡ä»¶å¤´
            with open(trace_filename, 'w') as f:
                f.write("")
        ##@@-- 20251103-Add File system

    def send(self, trace_pkg: Trace_Pkg, sram_full=False):
        """
        Send trace packet, update output signals, and print readable format
        """
        self.trace_data = trace_pkg.to_int()
        self.trace_valid = 1
        self.irq = 1 if sram_full else 0

        ##@@-- 20251103-Add File system
        if self.file_writer:
            self.file_writer.save_signal(self.trace_valid, self.trace_data)
        ##@@-- 20251103-Add File system

        # Formatted print (green)
        print("\033[32m" + f"TRACE_VALID={self.trace_valid}, "
              f"Branch_addr=0x{trace_pkg.Branch_addr:08X}, "
              f"inst_cnt={trace_pkg.inst_cnt}, "
              f"Br_tkn={trace_pkg.Br_tkn:032b}, "
              f"extend={trace_pkg.extend}, "
              f"IRQ={self.irq}" + "\033[0m")


## ===============================
## Control Register Class
## ===============================
class Control_Register:
    """
    Control register for enabling/disabling BETR encoder
    """
    def __init__(self, initial_value=0):
        self.ctrl_enable = initial_value  # 0: Disabled, 1: Enabled
    
    def enable(self):
        """Enable encoder"""
        self.ctrl_enable = 1
        print("\033[33m BETR Encoder Enabled\033[0m")
    
    def disable(self):
        """Disable encoder"""
        self.ctrl_enable = 0
        print("\033[33m BETR Encoder Disabled\033[0m")
    
    def is_enabled(self):
        """Check if enabled"""
        return self.ctrl_enable == 1


## ===============================
## Status Register Class
## ===============================
class Status_Register:
    """
    Status register holding current encoder state
    bit[0]: enable_status     - Encoder enable status (read-only)
    bit[1]: sram_full         - SRAM full status (read-only)  
    bit[2]: stop_address_hit  - Stop address hit (read-only)
    bit[3]: irq_pending       - Interrupt pending status (read-only)
    """
    def __init__(self):
        self.enable_status = 0      # bit0
        self.sram_full = 0          # bit1
        self.stop_address_hit = 0   # bit2  
        self.irq_pending = 0        # bit3  
    
    def read(self):
        """Read status register value"""
        return (self.irq_pending << 3) | (self.stop_address_hit << 2) | \
               (self.sram_full << 1) | self.enable_status
    
    def update_enable(self, enabled):
        """Update enable status"""
        self.enable_status = 1 if enabled else 0
    
    def update_sram_full(self, full):
        """Update SRAM full status"""
        self.sram_full = 1 if full else 0
    
    def set_stop_address_hit(self):
        """Set stop address hit flag"""
        self.stop_address_hit = 1
    
    def clear_stop_address_hit(self):
        """Clear stop address hit flag"""
        self.stop_address_hit = 0
    
    def set_irq_pending(self):
        """Set interrupt pending flag"""
        self.irq_pending = 1
    
    def clear_irq_pending(self):
        """Clear interrupt pending flag"""
        self.irq_pending = 0
    
    def __str__(self):
        """String representation for debugging"""
        status_bits = [
            f"ENABLE={self.enable_status}",
            f"SRAM_FULL={self.sram_full}",
            f"STOP_HIT={self.stop_address_hit}",
            f"IRQ_PENDING={self.irq_pending}"
        ]
        return f"STATUS[0x{self.read():02X}]: " + " | ".join(status_bits)


## ===============================
## Stop Address Register Class
## ===============================
class Stop_Address_Register:
    """
    Stop address register, triggers interrupt when PC == stop_address
    """
    def __init__(self):
        self.stop_address = 0xFFFFFFFF  # Default: no stop address set
        self.enabled = 0                # Whether stop address feature is enabled
    
    def write(self, address, enable):
        """Write stop address and enable bit"""
        self.stop_address = address
        self.enabled = enable
        if enable:
            print(f"\033[36m STOP-ADDRESS: 0x{address:08X} (Enabled)\033[0m")
        else:
            print(f"\033[36m STOP-ADDRESS: Disabled\033[0m")
    
    def check_stop_address(self, pc):
        """Check if stop address is hit"""
        if self.enabled and pc == self.stop_address:
            print(f"\033[35m STOP-ADDRESS HIT! PC=0x{pc:08X}\033[0m")
            return True
        return False


## ===============================
## IRQ Control Register Class
## ===============================
class IRQ_Control_Register:
    """
    Interrupt control register for clearing interrupts
    """
    def __init__(self):
        self.irq_active = 0
    
    def set_irq(self):
        """Set interrupt"""
        self.irq_active = 1
    
    def clear_irq(self):
        """Clear interrupt"""
        self.irq_active = 0
        print("\033[36m IRQ Cleared\033[0m")
    
    def is_irq_active(self):
        """Check if interrupt is active"""
        return self.irq_active == 1


## ===============================
## Instruction Classification & Length Detection
## ===============================
def is_compressed(instr: RVFI_Instr):
    """
    Check if instruction is 16-bit compressed
    """
    return instr.is_compressed  # Compressed instruction: last two bits != 11



def classify_instr(instr: RVFI_Instr):
    """
    Instruction classification:
    - NORMAL       : Normal instruction
    - BR_TKN       : Conditional branch taken  
    - BR_NOT_TKN   : Conditional branch not taken
    - INDIRECT     : Indirect jump (JALR)
    - TRAP         : Interrupt/exception
    """

    # InDirect Jump
    JALR = 0x19

    # Branch
    EQ   = 0x17
    NE   = 0x18
    LTS  = 0x13
    GES  = 0x15
    LTU  = 0x14
    GEU  = 0x16

    # Trap / exception
    if instr.ex_valid:
        return 'TRAP'

    # Indirect jump
    if instr.inst_op == 'JALR':
        return 'INDIRECT'

    # Branch instructions
    branch_ops = {'EQ', 'NE', 'LTS', 'GES', 'LTU', 'GEU'}
    if instr.inst_op in branch_ops:
        if instr.is_taken:
            return 'BR_TKN'
        else:
            return 'BR_NOT_TKN'

    # Default normal instruction
    return 'NORMAL'



## ===============================
## BETR Encoder Main Program
## ===============================
class BETR_Encoder:
    def __init__(self, sram_max_len=16,trace_filename = None):
        self.trace_out = Trace_Output(trace_filename)
        self.inst_cnt = 0
        self.ctrl_reg = Control_Register(0)  # Default: disabled
        self.status_reg = Status_Register()  # Use new status register
        self.stop_addr_reg = Stop_Address_Register()  # Stop address register
        self.irq_ctrl_reg = IRQ_Control_Register()    # IRQ control register
        self.last_enable_state = 0    # Record previous enable state
        self.missed_instructions = 0  # Count missed instructions
        self.br_tkn = 0
        self.sram_buffer = []         # Simulate SRAM
        self.sram_max_len = sram_max_len
        self.sram_used = 0
        self.curr_branch_addr = None  # Current instruction block start address

    def process_instr(self, instr: RVFI_Instr):
        if not instr.valid:
            return  # Ignore invalid instructions

        # If IRQ is already active (from previous stop address hit or SRAM full), skip processing
        if self.irq_ctrl_reg.is_irq_active():
            print(f"\033[90mInstruction PC=0x{instr.pc:08X} | IRQ active, skipping instruction\033[0m")
            return

        # Check stop address hit - triggers IRQ and stops processing
        if self.stop_addr_reg.check_stop_address(instr.pc):
            self._trigger_irq_stop_address()
            return  # Stop processing further instructions when stop address is hit

        # Detect enable state change
        current_enable = self.ctrl_reg.is_enabled()
        if self.last_enable_state == 0 and current_enable == 1:
            # Disabled â†’ Enabled: reset statistics, start new instruction block
            print(f"\033[35m Encoder enabled, starting new instruction block, PC=0x{instr.pc:08X}\033[0m")
            self.inst_cnt = 0
            self.br_tkn = 0
            self.curr_branch_addr = instr.pc
        elif self.last_enable_state == 1 and current_enable == 0:
            # Enabled â†’ Disabled: record state change
            print(f"\033[35m Encoder disabled, stopping statistics at PC=0x{instr.pc:08X}\033[0m")
            
        self.last_enable_state = current_enable

        # Check if encoder is enabled
        if not self.ctrl_reg.is_enabled():
            # Hardware real behavior: completely skip this instruction, no processing
            self.missed_instructions += 1
            print(f"\033[90mInstruction PC=0x{instr.pc:08X} | Encoder disabled, instruction missed (Total missed: {self.missed_instructions})\033[0m")
            return
            
        instr_type = classify_instr(instr)

        # Initialize current instruction block start address
        if self.curr_branch_addr is None:
            self.curr_branch_addr = instr.pc

        # Accumulate instruction length
        self.inst_cnt += 2 if not is_compressed(instr) else 1

        # Update br_tkn only valid for branch instructions
        if instr_type in ['BR_TAKEN', 'BR_NOT_TAKEN']:
            self.br_tkn = (self.br_tkn << 1) | (1 if instr_type == 'BR_TAKEN' else 0)

        # Extend bit, only valid for TRAP
        extend = 1 if instr_type == 'TRAP' else 0

        # Print each instruction information
        branch_addr_str = f"0x{self.curr_branch_addr:08X}" if self.curr_branch_addr is not None else "N/A"
        print(f"Instruction PC=0x{instr.pc:08X} | Type={instr_type:12s} | "
              f"Compressed={'Yes(16bit)' if is_compressed(instr) else 'No(32bit)'} | "
              f"inst_cnt={self.inst_cnt:02d} | br_tkn={self.br_tkn:032b} | "
              f"branch_addr={branch_addr_str}")

        # Determine if trace packet should be sent
        send_flag, send_reason = self.should_send(instr)
        if send_flag:
            self._send_trace_packet(send_reason, extend)

    def _trigger_irq_stop_address(self):
        """Trigger IRQ due to stop address hit"""
        self.status_reg.set_stop_address_hit()
        self.irq_ctrl_reg.set_irq()
        self.status_reg.set_irq_pending()
        self.trace_out.irq = 1
        print("\033[31m Stop address hit, IRQ asserted - waiting for CLR_IRQ\033[0m")

    def _trigger_irq_sram_full(self):
        """Trigger IRQ due to SRAM full"""
        self.irq_ctrl_reg.set_irq()
        self.status_reg.set_irq_pending()
        self.trace_out.irq = 1
        print("\033[31m SRAM full, cannot send packet, IRQ asserted - waiting for CLR_IRQ\033[0m")

    def _send_trace_packet(self, send_reason, extend):
        """Send trace packet with proper IRQ handling"""
        sram_full = self.sram_used >= self.sram_max_len
        self.status_reg.update_sram_full(sram_full)  # Update SRAM full status
        
        if not sram_full:
            trace_pkg = Trace_Pkg(self.curr_branch_addr, self.inst_cnt, self.br_tkn, extend)
            print(f"ğŸ“¦ Trigger packet send: {send_reason}")
            self.trace_out.send(trace_pkg, sram_full=False)  # Always pass sram_full=False to send()
            self.sram_buffer.append(trace_pkg.to_int())
            self.sram_used += 1
            self.inst_cnt = 0
            self.br_tkn = 0
            self.curr_branch_addr = None  # Reset for next block
        else:
            self._trigger_irq_sram_full()

    def should_send(self, instr: RVFI_Instr):
        """
        Return: (whether to send packet, send reason)
        """
        instr_type = classify_instr(instr)
        if self.inst_cnt >= 1023:
            return True, 'inst_cnt_max'
        if self.br_tkn & 0x80000000:
            return True, 'br_tkn_full'
        if instr.trap:
            return True, 'trap'
        if instr_type == 'INDIRECT':
            return True, 'indirect'
        return False, ''

    def set_enable(self, enable):
        """Set encoder enable state"""
        if enable:
            self.ctrl_reg.enable()
            self.status_reg.update_enable(True)  # Update status register
        else:
            self.ctrl_reg.disable()
            self.status_reg.update_enable(False)  # Update status register

    def set_stop_address(self, address, enable=True):
        """Set stop address"""
        self.stop_addr_reg.write(address, enable)

    def clear_irq(self):
        """Clear interrupt - common for both SRAM full and stop address hit"""
        self.irq_ctrl_reg.clear_irq()
        self.status_reg.clear_irq_pending()
        self.status_reg.clear_stop_address_hit()  # Also clear stop address hit flag
        self.status_reg.update_sram_full(False)   # Also clear SRAM full status
        self.trace_out.irq = 0
        print("\033[36m All IRQ sources cleared (SRAM full + Stop address hit)\033[0m")

    def read_status(self):
        """Read status register"""
        return self.status_reg.read()

    def get_stats(self):
        """Get statistics"""
        return {
            "total_missed": self.missed_instructions,
            "sram_packets": len(self.sram_buffer),
            "current_enabled": self.ctrl_reg.is_enabled(),
            "status_register": self.status_reg.read(),
            "irq_active": self.irq_ctrl_reg.is_irq_active()
        }

    def reset(self):
        """Complete encoder reset"""
        self.inst_cnt = 0
        self.br_tkn = 0
        self.sram_buffer = []
        self.sram_used = 0
        self.curr_branch_addr = None
        self.last_enable_state = 0
        self.missed_instructions = 0
        self.ctrl_reg.disable()
        self.status_reg = Status_Register()
        self.stop_addr_reg = Stop_Address_Register()
        self.irq_ctrl_reg = IRQ_Control_Register()
        self.trace_out.irq = 0
        print("\033[36m BETR Encoder completely reset\033[0m")

def gen_instr_stream(normal_len=4, branch_tk_len=2, trap_len=1, indirect_len=1, start_pc=0x1000):
    """
    Automatically generate test instruction stream
    """
    instr_stream = []
    pc = start_pc

    # Block 1: Normal instructions
    for _ in range(normal_len):
        instr_stream.append(RVFI_Instr(pc=pc, next_pc=pc+4, insn=0x00000013, valid=True))
        pc += 4

    # Block 2: Conditional branches (some taken, some not)
    for i in range(branch_tk_len):
        next_pc = pc + 8 if i % 2 == 0 else pc + 4
        instr_stream.append(RVFI_Instr(pc=pc, next_pc=next_pc, insn=0x00000063, valid=True))
        pc = next_pc

    # Block 3: TRAP instructions
    for _ in range(trap_len):
        instr_stream.append(RVFI_Instr(pc=pc, next_pc=pc+4, insn=0x00000093, valid=True, trap=True))
        pc += 4

    # Block 4: Indirect jumps
    for _ in range(indirect_len):
        instr_stream.append(RVFI_Instr(pc=pc, next_pc=pc+4, insn=0x00000667, valid=True))
        pc += 4

    return instr_stream


# ## ===============================
# ## Test Functions
# ## ===============================

# def test_basic_functionality():
#     """æµ‹è¯•åŸºæœ¬åŠŸèƒ½ï¼šæ­£å¸¸æŒ‡ä»¤å¤„ç†å’Œæ•°æ®åŒ…ç”Ÿæˆ"""
#     print("ğŸ§ª Testing Basic Functionality")
#     betr = BETR_Encoder(sram_max_len=4, trace_filename="test_basic_trace.txt")
    
#     # ç”Ÿæˆç®€å•çš„æŒ‡ä»¤æµ
#     instr_stream = gen_instr_stream(normal_len=5, branch_tk_len=2, trap_len=0, indirect_len=1)
    
#     betr.set_enable(True)
    
#     for i, instr in enumerate(instr_stream):
#         print(f"Processing instruction {i+1}: PC=0x{instr.pc:08X}")
#         betr.process_instr(instr)
    
#     stats = betr.get_stats()
#     print(f"âœ… Basic test completed: {stats['sram_packets']} packets generated")
#     return betr

# def test_stop_address_feature():
#     """æµ‹è¯•åœæ­¢åœ°å€åŠŸèƒ½"""
#     print("\nğŸ§ª Testing Stop Address Feature")
#     betr = BETR_Encoder(sram_max_len=4, trace_filename="test_stop_address_trace.txt")
    
#     # è®¾ç½®åœæ­¢åœ°å€åœ¨ä¸­é—´ä½ç½®
#     stop_pc = 0x100C
#     betr.set_stop_address(stop_pc, enable=True)
#     betr.set_enable(True)
    
#     instr_stream = gen_instr_stream(normal_len=10, branch_tk_len=0, trap_len=0, indirect_len=0)
    
#     irq_triggered = False
#     for i, instr in enumerate(instr_stream):
#         betr.process_instr(instr)
#         if betr.irq_ctrl_reg.is_irq_active():
#             print(f"âœ… Stop address IRQ triggered at PC=0x{instr.pc:08X}")
#             irq_triggered = True
#             break
    
#     if not irq_triggered:
#         print("âŒ Stop address IRQ was not triggered")
    
#     return betr

# def test_sram_full_condition():
#     """æµ‹è¯•SRAMæ»¡æ¡ä»¶"""
#     print("\nğŸ§ª Testing SRAM Full Condition")
#     # ä½¿ç”¨å¾ˆå°çš„SRAMæ¥å¿«é€Ÿè§¦å‘æ»¡æ¡ä»¶
#     betr = BETR_Encoder(sram_max_len=2, trace_filename="test_sram_full_trace.txt")
    
#     betr.set_enable(True)
    
#     # ç”Ÿæˆè¶³å¤Ÿå¤šçš„åˆ†æ”¯æŒ‡ä»¤æ¥è§¦å‘å¤šä¸ªæ•°æ®åŒ…
#     instr_stream = gen_instr_stream(normal_len=2, branch_tk_len=10, trap_len=0, indirect_len=0)
    
#     for i, instr in enumerate(instr_stream[:8]):  # åªå¤„ç†å‰8æ¡
#         betr.process_instr(instr)
#         if betr.irq_ctrl_reg.is_irq_active():
#             print(f"âœ… SRAM full IRQ triggered after {i+1} instructions")
#             break
    
#     return betr

# def test_encoder_enable_disable():
#     """æµ‹è¯•ç¼–ç å™¨å¯ç”¨/ç¦ç”¨åŠŸèƒ½"""
#     print("\nğŸ§ª Testing Encoder Enable/Disable")
#     betr = BETR_Encoder(sram_max_len=4, trace_filename="test_enable_disable_trace.txt")
    
#     instr_stream = gen_instr_stream(normal_len=10, branch_tk_len=2, trap_len=0, indirect_len=0)
    
#     # é˜¶æ®µ1: ç¦ç”¨çŠ¶æ€
#     print("Phase 1: Encoder Disabled")
#     betr.set_enable(False)
#     for i in range(3):
#         betr.process_instr(instr_stream[i])
    
#     # é˜¶æ®µ2: å¯ç”¨çŠ¶æ€
#     print("Phase 2: Encoder Enabled")
#     betr.set_enable(True)
#     for i in range(3, 6):
#         betr.process_instr(instr_stream[i])
    
#     # é˜¶æ®µ3: å†æ¬¡ç¦ç”¨
#     print("Phase 3: Encoder Disabled Again")
#     betr.set_enable(False)
#     for i in range(6, 8):
#         betr.process_instr(instr_stream[i])
    
#     stats = betr.get_stats()
#     print(f"âœ… Enable/disable test completed: {stats['total_missed']} instructions missed")
#     return betr

# def test_comprehensive_scenario():
#     """æµ‹è¯•ç»¼åˆåœºæ™¯"""
#     print("\nğŸ§ª Testing Comprehensive Scenario")
#     betr = BETR_Encoder(sram_max_len=4, trace_filename="test_comprehensive_trace.txt")
    
#     # è®¾ç½®åœæ­¢åœ°å€
#     betr.set_stop_address(0x1018, enable=True)
    
#     instr_stream = gen_instr_stream(normal_len=8, branch_tk_len=4, trap_len=1, indirect_len=2)
    
#     print("Starting comprehensive test...")
#     betr.set_enable(True)
    
#     for i, instr in enumerate(instr_stream):
#         print(f"Instruction {i+1}: PC=0x{instr.pc:08X}")
#         betr.process_instr(instr)
        
#         # æ£€æŸ¥æ˜¯å¦è§¦å‘åœæ­¢åœ°å€IRQ
#         if betr.irq_ctrl_reg.is_irq_active():
#             print("ğŸ›‘ Stop address hit - clearing IRQ")
#             betr.clear_irq()
#             break
    
#     return betr

# def run_all_tests():
#     """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
#     print("=" * 70)
#     print("BETR Encoder Test Suite")
#     print("=" * 70)
    
#     test_results = []
    
#     # è¿è¡Œå„ä¸ªæµ‹è¯•
#     test_functions = [
#         test_basic_functionality,
#         test_stop_address_feature, 
#         test_sram_full_condition,
#         test_encoder_enable_disable,
#         test_comprehensive_scenario
#     ]
    
#     for test_func in test_functions:
#         try:
#             encoder = test_func()
#             stats = encoder.get_stats()
#             test_results.append({
#                 'test': test_func.__name__,
#                 'packets': stats['sram_packets'],
#                 'missed': stats['total_missed'],
#                 'status': 'PASS'
#             })
#         except Exception as e:
#             test_results.append({
#                 'test': test_func.__name__, 
#                 'packets': 0,
#                 'missed': 0,
#                 'status': f'FAIL: {e}'
#             })
    
#     # æ‰“å°æµ‹è¯•æ€»ç»“
#     print("\n" + "=" * 70)
#     print("Test Summary")
#     print("=" * 70)
#     for result in test_results:
#         status_icon = "âœ…" if result['status'] == 'PASS' else "âŒ"
#         print(f"{status_icon} {result['test']}: {result['status']}")
#         print(f"   Packets: {result['packets']}, Missed: {result['missed']}")
    
#     print(f"\nTotal tests: {len(test_results)}")
#     passed = sum(1 for r in test_results if r['status'] == 'PASS')
#     print(f"Passed: {passed}, Failed: {len(test_results) - passed}")


## ===============================
## Example Usage
## ===============================
if __name__ == "__main__":
    # æ–¹å¼1: è¿è¡Œæ‰€æœ‰æµ‹è¯•
    # run_all_tests()
    
    # æ–¹å¼2: è¿è¡Œå•ä¸ªæµ‹è¯•
    # test_basic_functionality()
    # test_stop_address_feature()
    print(f"\nTEST.")
    # æ–¹å¼3: åŸæœ‰çš„æ¼”ç¤ºä»£ç ï¼ˆå¦‚æœéœ€è¦ä¿ç•™ï¼‰
    # run_original_demo()