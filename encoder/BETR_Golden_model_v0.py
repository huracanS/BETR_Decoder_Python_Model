## ===============================
## 一、RVFI 接口
## ===============================
class RVFI_Instr:
    """
    RVFI interface input instruction class
    """
    def __init__(self, pc, inst_op, valid,
                 is_compressed, is_branch, is_taken, ex_valid):
        self.valid = valid                   # 指令有效信号
        self.pc = pc                         # 指令地址
        self.inst_op = inst_op               # 指令类型
        self.is_compressed = is_compressed   # 是否压缩指令
        self.is_branch = is_branch           # 是否跳转指令
        self.is_taken = is_taken             # 跳转是否
        self.ex_valid = ex_valid             # 是否中断或异常

## ===============================
## 二、Trace 包
## ===============================
class Trace_Pkg:
    """
    Trace packet generated by BETR encoder
    """
    def __init__(self, branch_addr, inst_cnt, br_tkn, extend=0):
        self.Branch_addr = branch_addr  # 32-bit 指令块的起始地址
        self.inst_cnt = inst_cnt        # 10-bit 指令块中指令计数值 32bit + 2 ,16bit + 1
        self.Br_tkn = br_tkn            # 32-bit 指令块中分支跳转信息
        self.extend = extend            # 1-bit  是否中断异常标志位

    def to_int(self):
        """
        Pack trace packet into single integer (75-bit)
        Format: Branch_addr[31:0] + inst_cnt[9:0] + Br_tkn[31:0] + extend[0]
        """
        return (self.Branch_addr << (10 + 32 + 1)) | (self.inst_cnt << (32 + 1)) | (self.Br_tkn << 1) | self.extend

## ===============================
## 三、Log导入系统
## ===============================

class LogFileImporter:
    """.log文件导入器"""
    
    def __init__(self):
        self.imported_data = []
    
    def import_log_file(self, filename):
        """
        导入.log文件并转换为RVFI指令
        
        支持格式:
        valid:1,PC:0x00010000,Inst:0x00,is_branch:0,is_taken:0,is_compressed:0,ex_valid:0
        """
        self.imported_data = []
        
        try:
            with open(filename, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line or line.startswith("#") or line.startswith("Cycle"):
                        continue
                    
                    # 解析数据
                    instr = self._parse_log_line(line, line_num)
                    if instr:
                        self.imported_data.append(instr)
            
            print(f"成功导入 {len(self.imported_data)} 条指令来自 {filename}")
            return self.imported_data
            
        except FileNotFoundError:
            print(f"【ERROR】文件未找到: {filename}")
            return []
        except Exception as e:
            print(f"【ERROR】导入文件时出错: {e}")
            return []
    
    def _parse_log_line(self, line, line_num):
        """解析单行日志数据"""
        try:
            data = {}
            pairs = line.split(',')
            
            for pair in pairs:
                if ':' in pair:
                    key, value = pair.split(':', 1)
                    data[key.strip()] = value.strip()
            
            # 检查必需字段
            if 'valid' not in data or data['valid'] != '1':
                return None
            
            # 创建RVFI指令对象
            instr = RVFI_Instr(
                pc=int(data['PC'], 16) & 0xFFFFFFFF,           # 32位PC
                inst_op=int(data.get('Inst', '0'), 16) & 0xFF, # 8位操作码
                valid=True,
                is_compressed=data.get('is_compressed') == '1',
                is_branch=data.get('is_branch') == '1',
                is_taken=data.get('is_taken') == '1',
                ex_valid=data.get('ex_valid') == '1'
            )
            
            # # 添加打印命令
            # print(f"RVFI指令信息: PC=0x{instr.pc:08X}, 操作码=0x{instr.inst_op:02X}, "
            #     f"压缩={instr.is_compressed}, 分支={instr.is_branch}, "
            #     f"分支跳转={instr.is_taken}, 是否异常中断={instr.ex_valid}")

            return instr
            
        except Exception as e:
            print(f"【ERROR】第 {line_num} 行解析失败: {line} - {e}")
            return None
    
    def get_imported_data(self):
        """获取导入的数据"""
        return self.imported_data
    
    def clear_data(self):
        """清空导入的数据"""
        self.imported_data = []
        print("已清空导入数据")

##@@-- 20251103-Add File system
## ===============================
## 四、发送数据包写入系统.
## ===============================
## Trace信号文件输出器：保存trace_valid和trace_data（用于DEBUG查看数据包内容）.
class TraceSignalWriter:
    """Trace信号文件输出器 - 只保存trace_valid和trace_data"""
    
    def __init__(self, filename="trace_signals.txt"):
        self.filename = filename
        
    def save_signal(self, trace_valid, branch_addr, inst_cnt, br_tkn, extend):
        """保存信号到文件，格式为可读文本"""
        with open(self.filename, 'a') as f:
            line = (f"trace_valid:{trace_valid}, "
                    f"branch_addr:0x{branch_addr:08X}, "
                    f"inst_cnt:{inst_cnt}, "
                    f"br_tkn:0b{br_tkn:032b}, "
                    f"extend:{extend}\n")
            f.write(line)

# Trace信号文件输出器：保存trace_valid和trace_data（完整格式，用于输出给解码器）.
class TracePkgWriter:
    """保存trace包的纯整数信息"""
    def __init__(self, filename="trace_pkg_only.txt"):
        self.filename = filename
        with open(self.filename, 'w') as f:
            f.write("")  # 清空文件

    def save_pkg(self, trace_pkg: Trace_Pkg):
        with open(self.filename, 'a') as f:
            f.write(f"{trace_pkg.to_int():019X}\n")
##@@-- 20251106-Add Package Saver.

## ===============================
## 五、输出文件系统
## ===============================
class Trace_Output:
    """
    Simulates BETR encoder output signals
    """
    def __init__(self,trace_filename = None, pkg_filename=None):
        self.trace_valid = 0
        self.trace_data = 0
        self.irq = 0
        
        ##@@-- 20251103-Add File system
        self.file_writer = None
        if trace_filename:
            self.file_writer = TraceSignalWriter(trace_filename)
            # 写入文件头
            with open(trace_filename, 'w') as f:
                f.write("")
        ##@@-- 20251103-Add File system

        ##@@-- 20251106-Add Package Saver.
        self.pkg_writer = None
        if pkg_filename:
            self.pkg_writer = TracePkgWriter(pkg_filename)
            with open(pkg_filename, 'w') as f: f.write("")
        ##@@-- 20251106-Add Package Saver.

    def send(self, trace_pkg: Trace_Pkg, sram_full=False):
        """
        Send trace packet, update output signals, and print readable format
        """
        self.trace_data = trace_pkg.to_int()
        self.trace_valid = 1
        self.irq = 1 if sram_full else 0

        ##@@-- 20251103-Add File system
        if self.file_writer:
            self.file_writer.save_signal(
                trace_valid=self.trace_valid,
                branch_addr=trace_pkg.Branch_addr,
                inst_cnt=trace_pkg.inst_cnt,
                br_tkn=trace_pkg.Br_tkn,
                extend=trace_pkg.extend
            )
        ##@@-- 20251103-Add File system

        ##@@-- 20251106-Add Package Saver.
        if self.pkg_writer:
            self.pkg_writer.save_pkg(trace_pkg)
        ##@@-- 20251106-Add Package Saver.

        # Formatted print (green)
        print("\033[32m" + f"TRACE_VALID={self.trace_valid}, "
              f"Branch_addr=0x{trace_pkg.Branch_addr:08X}, "
              f"inst_cnt={trace_pkg.inst_cnt}, "
              f"Br_tkn={trace_pkg.Br_tkn:032b}, "
              f"extend={trace_pkg.extend}, "
              f"IRQ={self.irq}" + "\033[0m")


## ===============================
## 六、控制寄存器
## ===============================

# 1 - 使能寄存器
class Control_Register:
    """
    Control register for enabling/disabling BETR encoder
    """
    def __init__(self, initial_value=0):
        self.ctrl_enable = initial_value  # 0: Disabled, 1: Enabled
    
    # 使能BETR追踪功能
    def enable(self):
        """Enable encoder"""
        self.ctrl_enable = 1
        print("\033[33m BETR Encoder Enabled\033[0m")
    
    # 关闭BETR追踪功能
    def disable(self):
        """Disable encoder"""
        self.ctrl_enable = 0
        print("\033[33m BETR Encoder Disabled\033[0m")
    
    # 查看BETR是否开启
    def is_enabled(self):
        """Check if enabled"""
        return self.ctrl_enable == 1

# 2 - 停止地址寄存器
class Stop_Address_Register:
    """
    Stop address register, triggers interrupt when PC == stop_address
    """
    def __init__(self):
        self.stop_address = 0xFFFFFFFF  # Default: no stop address set
        self.enabled = 0                # Whether stop address feature is enabled
    
    def write(self, address, enable):
        """Write stop address and enable bit"""
        self.stop_address = address
        self.enabled = enable
        if enable:
            print(f"\033[36m STOP-ADDRESS: 0x{address:08X} (Enabled)\033[0m")
        else:
            print(f"\033[36m STOP-ADDRESS: Disabled\033[0m")
    
    def check_stop_address(self, pc):
        """Check if stop address is hit"""
        if self.enabled and pc == self.stop_address:
            print(f"\033[35m STOP-ADDRESS HIT! PC=0x{pc:08X}\033[0m")
            return True
        return False

# 3 - 中断控制寄存器
class IRQ_Control_Register:
    """
    Interrupt control register for clearing interrupts
    """
    def __init__(self):
        self.irq_active = 0
    
    def set_irq(self):
        """Set interrupt"""
        self.irq_active = 1
    
    def clear_irq(self):
        """Clear interrupt"""
        self.irq_active = 0
        print("\033[36m IRQ Cleared\033[0m")
    
    def is_irq_active(self):
        """Check if interrupt is active"""
        return self.irq_active == 1

## ===============================
## 七、状态寄存器
## ===============================
class Status_Register:
    """
    Status register holding current encoder state
    bit[0]: enable_status     - Encoder enable status (read-only)
    bit[1]: sram_full         - SRAM full status (read-only)  
    bit[2]: stop_address_hit  - Stop address hit (read-only)
    bit[3]: irq_pending       - Interrupt pending status (read-only)
    """
    def __init__(self):
        self.enable_status = 0      # bit0
        self.sram_full = 0          # bit1
        self.stop_address_hit = 0   # bit2  
        self.irq_pending = 0        # bit3  
    
    def read(self):
        """Read status register value"""
        return (self.irq_pending << 3) | (self.stop_address_hit << 2) | \
               (self.sram_full << 1) | self.enable_status
    
    def update_enable(self, enabled):
        """Update enable status"""
        self.enable_status = 1 if enabled else 0
    
    def update_sram_full(self, full):
        """Update SRAM full status"""
        self.sram_full = 1 if full else 0
    
    def set_stop_address_hit(self):
        """Set stop address hit flag"""
        self.stop_address_hit = 1
    
    def clear_stop_address_hit(self):
        """Clear stop address hit flag"""
        self.stop_address_hit = 0
    
    def set_irq_pending(self):
        """Set interrupt pending flag"""
        self.irq_pending = 1
    
    def clear_irq_pending(self):
        """Clear interrupt pending flag"""
        self.irq_pending = 0
    
    def __str__(self):
        """String representation for debugging"""
        status_bits = [
            f"ENABLE={self.enable_status}",
            f"SRAM_FULL={self.sram_full}",
            f"STOP_HIT={self.stop_address_hit}",
            f"IRQ_PENDING={self.irq_pending}"
        ]
        return f"STATUS[0x{self.read():02X}]: " + " | ".join(status_bits)




## ===============================
## 八、指令是否压缩
## ===============================
def is_compressed(instr: RVFI_Instr):
    """
    Check if instruction is 16-bit compressed
    """
    return instr.is_compressed  # Compressed instruction: last two bits != 11

## ===============================
## 九、指令识别类型
## ===============================
def classify_instr(instr: RVFI_Instr):
    """
    Instruction classification:
    - NORMAL       : Normal instruction
    - BR_TAKEN     : Conditional branch taken  
    - BR_NOT_TKN   : Conditional branch not taken
    - INDIRECT     : Indirect jump (JALR)
    - TRAP         : Interrupt/exception
    - CALL         : CALL PUSH THE STACK
    - RETURN       : RETURN POP THE STACK
    """

    # Trap / exception
    if instr.ex_valid:
        return 'TRAP'

    # Indirect jump
    # 区分成三种间接分支指令类型：
    #   还要考虑RET指令，RET指令是什么类型
    #   1.JALR，目标地址是RET的类型，当作间接跳转包处理发送数据包；
    #   2.JALR，目标地址不是RET的类型，执行压栈操作；
    #   3.MRET/SRET/DRET：视为间接跳转包处理发送数据包。
    
    # # @TODO:Need to add CALL/RET Recognization.
    if instr.inst_op == 0x13:
        return 'INDIRECT'
    # # CALL、RETURN
    # call_op = 
    # if instr.inst_op in indirect_ops:# MRET,SRET,DRET
    #     return 'CALL'
    # return_op = 
    # if instr.inst_op in indirect_ops:# MRET,SRET,DRET
    #     return 'RETURN'
    # # @TODO:Need to add CALL/RET Recognization.

    # MRET、SRET、DRET 视为中断的处理方式
    indirect_ops = {0x17,0x18,0x19}
    if instr.inst_op in indirect_ops:# MRET,SRET,DRET
        return 'INDIRECT'

    # Branch指令 区分Taken和Not_Taken
    branch_ops = {0x11, 0x12, 0x0D, 0x0F, 0x0E, 0x10}  # EQ, NE, LTS, GES, LTU, GEU
    if instr.inst_op in branch_ops:
        if instr.is_taken:
            return 'BR_TAKEN'
        else:
            return 'BR_NOT_TAKEN'

    # 普通指令
    return 'NORMAL'


## ===============================
## BETR Encoder Main Program
## ===============================
class BETR_Encoder:
    def __init__(self, sram_max_len=1024,trace_filename = None,stack_size=8):
        self.trace_out = Trace_Output(trace_filename)
        self.inst_cnt = 0
        self.br_cnt   = 0
        self.ctrl_reg = Control_Register(0)  # Default: disabled
        self.status_reg = Status_Register()  # Use new status register
        self.stop_addr_reg = Stop_Address_Register()  # Stop address register
        self.irq_ctrl_reg = IRQ_Control_Register()    # IRQ control register
        self.last_enable_state = 0    # Record previous enable state
        self.missed_instructions = 0  # Count missed instructions
        self.br_tkn = 0
        self.sram_buffer = []         # Simulate SRAM
        self.sram_max_len = sram_max_len
        self.sram_used = 0
        self.curr_branch_addr = None  # Current instruction block start address
        # +++ 新增：包类型统计（基于send_reason）+++
        self.pkg_type_stats = {
            'inst_cnt_max': 0,    # 指令计数满
            'br_tkn_full': 0,     # 分支历史满
            'trap': 0,            # 异常/中断
            'indirect': 0,        # 间接跳转
            'normal': 0           # 正常指令块
        }

        ##@@20251106-Add CALL/RETURN Stack
        self.ret_stack = [0] * stack_size
        self.stack_size = stack_size
        self.head = 0  # 压栈指针（CALL 写入）
        self.tail = 0  # 出栈指针（RET 读出）
        self.return_stack_addr = 0
        self.mis_stack = 0
        # 保存上一拍的指令类型
        self.prev_instr_type   = None # 保存上一拍的指令类型
        ##@@20251106-Add CALL/RETURN Stack

    def reset(self):
        """Complete encoder reset"""
        self.inst_cnt = 0
        self.br_cnt   = 0
        self.br_tkn = 0
        self.sram_buffer = []
        self.sram_used = 0
        self.curr_branch_addr = None
        self.last_enable_state = 0
        self.missed_instructions = 0

        # +++ 新增：重置包类型统计 +++
        for reason in self.pkg_type_stats:
            self.pkg_type_stats[reason] = 0

        self.ctrl_reg.disable()
        self.status_reg = Status_Register()
        self.stop_addr_reg = Stop_Address_Register()
        self.irq_ctrl_reg = IRQ_Control_Register()
        self.trace_out.irq = 0
        print("\033[36m BETR Encoder completely reset\033[0m")

    #@TODO:()
    ##@@20251106-Add CALL/RETURN Stack
    #1.堆栈的写入和弹出
    def handle_call_ret(self, instr_type, return_addr):

        if instr_type == 'CALL':
            next_head = (self.head + 1) % self.stack_size
            if next_head == self.tail:
                print(f"【STACK】CALL stack overflow at return_addr=0x{return_addr:08X}")
                return
            self.ret_stack[self.head] = return_addr
            print(f"【STACK】CALL detected: return_addr=0x{return_addr:08X}")
            self.head = next_head

        elif instr_type == 'RETURN':
            next_head = (self.head + 1) % self.stack_size
            if self.head == self.tail:
                print("【STACK】RET with empty stack")
                return 0
            # 出栈：tail 指针从 head 的前一个位置开始
            self.head = (self.head - 1 + self.stack_size) % self.stack_size
            self.return_stack_addr = self.ret_stack[self.head]
            print(f"【STACK】RET detected: jump back to 0x{self.return_stack_addr:08X}")
            return self.return_stack_addr
        
    #2.堆栈丢失信息后的减少和刷新

    #3.堆栈预测正确性的比较
    def check_return_address_is_miss(return_stack_addr,actual_addr):
        if(return_stack_addr == actual_addr) :
            print("栈预测返回地址正确！！！")
            return 0
        else :
            print("栈预测返回地址错误！！！")
            return 1
        
    #4.导出当前栈状态（用于调试或日志）
    def get_stack_status(self):
        print("【STACK】Current CALL/RET stack status:")
        print(f"  head={self.head}, tail={self.tail}")
        print(f"  stack contents={self.ret_stack}")
        return {
            'head': self.head,
            'tail': self.tail,
            'stack': self.ret_stack.copy()
        }
        
    ##@@20251106-Add CALL/RETURN Stack
    #@TODO:()

    # 指令计算的主函数
    def process_instr(self, instr: RVFI_Instr):
        # 1 - 指令无效跳过
        if not instr.valid:
            return  # Ignore invalid instructions

        # 2 - If IRQ is already active (from previous stop address hit or SRAM full), skip processing
        if self.irq_ctrl_reg.is_irq_active():
            print(f"\033[90mInstruction PC=0x{instr.pc:08X} | IRQ active, skipping instruction\033[0m")
            return

        # 3 - Check stop address hit - triggers IRQ and stops processing
        if self.stop_addr_reg.check_stop_address(instr.pc):
            self._trigger_irq_stop_address()
            return  # Stop processing further instructions when stop address is hit

        # 4 - Detect enable state change
        current_enable = self.ctrl_reg.is_enabled()
        if self.last_enable_state == 0 and current_enable == 1:
            # Disabled → Enabled: reset statistics, start new instruction block
            print(f"\033[35m Encoder enabled, starting new instruction block, PC=0x{instr.pc:08X}\033[0m")
            self.inst_cnt = 0
            self.br_tkn = 0
            self.curr_branch_addr = instr.pc
        elif self.last_enable_state == 1 and current_enable == 0:
            # Enabled → Disabled: record state change
            print(f"\033[35m Encoder disabled, stopping statistics at PC=0x{instr.pc:08X}\033[0m")
            
        self.last_enable_state = current_enable

        # 5 - Check if encoder is enabled
        if not self.ctrl_reg.is_enabled():
            # Hardware real behavior: completely skip this instruction, no processing
            self.missed_instructions += 1
            print(f"\033[90m Instruction PC=0x{instr.pc:08X} | Encoder disabled, instruction missed (Total missed: {self.missed_instructions})\033[0m")
            return
            
        instr_type = classify_instr(instr)

        # 6 - Initialize current instruction block start address
        if self.curr_branch_addr is None:
            self.curr_branch_addr = instr.pc

        # #@TODO:()
        # #STACK 
        # ret_stack_addr = handle_call_ret()
        # # 上一拍的指令类型为RETURN
        # if prev_instr_type == 'RETURN':
            # 出栈并判断是否正确
            # handle_call_ret(self, prev_instr_type, instr.pc)
            # self.mis_stack = self.check_return_address_is_miss(ret_stack_addr,instr.pc)
        # elif instr_type == 'CALL'
            # 压栈
            # handle_call_ret(self, instr_type, instr.pc)
        # #@TODO:()

        # Accumulate instruction length
        self.inst_cnt += 2 if not is_compressed(instr) else 1

        # Update br_tkn only valid for branch instructions
        if instr_type in ['BR_TAKEN', 'BR_NOT_TAKEN']:
            self.br_tkn = (self.br_tkn << 1) | (1 if instr_type == 'BR_TAKEN' else 0)
            self.br_cnt += 1

        # Extend bit, only valid for TRAP
        extend = 1 if instr_type == 'TRAP' else 0

        # Print each instruction information
        branch_addr_str = f"0x{self.curr_branch_addr:08X}" if self.curr_branch_addr is not None else "N/A"
        # print(f"Instruction PC=0x{instr.pc:08X} | Type={instr_type:12s} | "
        #       f"Compressed={'Yes(16bit)' if is_compressed(instr) else 'No(32bit)'} | "
        #       f"inst_cnt={self.inst_cnt:02d} | br_tkn={self.br_tkn:032b} | "
        #       f"branch_addr={branch_addr_str}")

        # Determine if trace packet should be sent
        send_flag, send_reason = self.should_send(instr)
        if send_flag:
            self._send_trace_packet(send_reason, extend)

        #@@TODO：（）
        # -------- 新增：保存上一拍指令类型 --------
        #@@TODO:()
        self.prev_instr_type = instr_type

    def _trigger_irq_stop_address(self):
        """Trigger IRQ due to stop address hit"""
        self.status_reg.set_stop_address_hit()
        self.irq_ctrl_reg.set_irq()
        self.status_reg.set_irq_pending()
        self.trace_out.irq = 1
        print("\033[31m Stop address hit, IRQ asserted - waiting for CLR_IRQ\033[0m")

    def _trigger_irq_sram_full(self):
        """Trigger IRQ due to SRAM full"""
        self.irq_ctrl_reg.set_irq()
        self.status_reg.set_irq_pending()
        self.trace_out.irq = 1
        print("\033[31m SRAM full, cannot send packet, IRQ asserted - waiting for CLR_IRQ\033[0m")

    def _send_trace_packet(self, send_reason, extend):
        """Send trace packet with proper IRQ handling"""
        sram_full = self.sram_used >= self.sram_max_len
        self.status_reg.update_sram_full(sram_full)  # Update SRAM full status
        
        if not sram_full:
            trace_pkg = Trace_Pkg(self.curr_branch_addr, self.inst_cnt, self.br_tkn, extend)

            # +++ 新增：基于send_reason更新包类型统计 +++
            if send_reason in self.pkg_type_stats:
                self.pkg_type_stats[send_reason] += 1
            else:
                self.pkg_type_stats['normal'] += 1  # 默认归为normal

            print(f"【Package】Trigger packet send: {send_reason}")
            self.trace_out.send(trace_pkg, sram_full=False)  # Always pass sram_full=False to send()
            self.sram_buffer.append(trace_pkg.to_int())
            self.sram_used += 1
            self.inst_cnt = 0
            self.br_cnt   = 0
            self.br_tkn = 0
            self.curr_branch_addr = None  # Reset for next block
        else:
            self._trigger_irq_sram_full()

    def should_send(self, instr: RVFI_Instr):
        """
        Return: (whether to send packet, send reason)
        """
        instr_type = classify_instr(instr)
        if self.inst_cnt >= 1023:
            return True, 'inst_cnt_max'
        if self.br_cnt >= 32: 
            return True, 'br_tkn_full'
        if instr.ex_valid == 1:
            return True, 'trap'
        #@TODO:()
        #if !self.mis_stack:
        #   return True, 'STACK_MISS'
        # 堆栈预测失败后发包
        #@TODO:()
        if instr_type == 'INDIRECT':
            return True, 'indirect'
        return False, ''

    def set_enable(self, enable):
        """Set encoder enable state"""
        if enable:
            self.ctrl_reg.enable()
            self.status_reg.update_enable(True)  # Update status register
        else:
            self.ctrl_reg.disable()
            self.status_reg.update_enable(False)  # Update status register

    def set_stop_address(self, address, enable=True):
        """Set stop address"""
        self.stop_addr_reg.write(address, enable)

    def clear_irq(self):
        """Clear interrupt - common for both SRAM full and stop address hit"""
        self.irq_ctrl_reg.clear_irq()
        self.status_reg.clear_irq_pending()
        self.status_reg.clear_stop_address_hit()  # Also clear stop address hit flag
        self.status_reg.update_sram_full(False)   # Also clear SRAM full status
        self.trace_out.irq = 0
        print("\033[36m All IRQ sources cleared (SRAM full + Stop address hit)\033[0m")

    def read_status(self):
        """Read status register"""
        return self.status_reg.read()

    def get_stats(self):
        """Get statistics"""
        return {
            "total_missed": self.missed_instructions,
            "sram_packets": len(self.sram_buffer),
            "current_enabled": self.ctrl_reg.is_enabled(),
            "status_register": self.status_reg.read(),
            "pkg_type_stats": self.pkg_type_stats.copy(),  # +++ 新增：包类型统计 ++
            "irq_active": self.irq_ctrl_reg.is_irq_active()
        }

    # +++ 新增方法：打印包类型统计信息 +++
    def print_package_statistics(self):
        """打印包类型统计信息"""
        print("\n" + "="*60)
        print("【PACKAGES】TRACE PACKAGE TYPE STATISTICS")
        print("="*60)
        
        total_packets = sum(self.pkg_type_stats.values())
        if total_packets == 0:
            print("No trace packets generated yet.")
            return
        
        # 定义类型名称映射
        type_names = {
            'inst_cnt_max': "Instruction Count Max",
            'br_tkn_full': "Branch History Full", 
            'trap': "Traps/Exceptions",
            'indirect': "Indirect Jumps",
            'normal': "Normal Blocks"
        }
        
        # 打印详细统计
        for reason in sorted(self.pkg_type_stats.keys()):
            count = self.pkg_type_stats[reason]
            percentage = (count / total_packets) * 100 if total_packets > 0 else 0
            type_name = type_names.get(reason, reason)
            
            print(f"  {type_name:<25}: {count:4d} packets ({percentage:6.2f}%)")
        
        print("-"*60)
        print(f"  {'TOTAL':<25}: {total_packets:4d} packets (100.00%)")
        print("="*60)

    def import_and_process_log(self, log_filename):
        """
        导入.log文件并立即处理
        
        Args:
            log_filename: .log文件路径
        """
        importer = LogFileImporter()
        instructions = importer.import_log_file(log_filename)
        
        if not instructions:
            print("❌没有可处理的指令")
            return
        
        print(f"【START】开始处理 {len(instructions)} 条指令...")
        
        # 处理所有导入的指令
        for i, instr in enumerate(instructions):
            # CONFIG():打印处理指令的信息
            # print(f"处理指令 {i+1}/{len(instructions)}: PC=0x{instr.pc:08X}")
            self.process_instr(instr)
        
        # 输出统计信息
        stats = self.get_stats()
        print(f"\n【FINISH】处理完成")
        print(f"   - 生成数据包: {stats['sram_packets']}")
        print(f"   - 丢失指令: {stats['total_missed']}")
        print(f"   - 压缩率: {1 - stats['sram_packets']/len(instructions):.2%}")

        # +++ 新增：打印包类型统计 +++
        self.print_package_statistics()



#####
## ===============================
## Test Functions for New BETR Encoder Interface
## ===============================
def gen_instr_stream(normal_len=4, branch_len=2, trap_len=1, indirect_len=1, start_pc=0x00001000):
    instr_stream = []
    pc = start_pc

    # Block 1: Normal instructions
    for _ in range(normal_len):
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op=0x00,       # 普通指令
            valid=True,
            is_compressed=False,
            is_branch=False,
            is_taken=False,
            ex_valid=False
        ))
        pc += 4

    # Block 2: Branch instructions
    branch_ops = ['EQ', 'NE', 'LTS', 'GES', 'LTU', 'GEU']
    for i in range(branch_len):
        op = branch_ops[i % len(branch_ops)]
        taken = (i % 2 == 0)
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op=op,
            valid=True,
            is_compressed=False,
            is_branch=True,
            is_taken=taken,
            ex_valid=False
        ))
        pc += 4

    # Block 3: Trap instructions
    for _ in range(trap_len):
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op=0x00,  # 任意操作码
            insn=0x00000093,
            valid=True,
            is_compressed=False,
            is_branch=False,
            is_taken=False,
            ex_valid=True
        ))
        pc += 4

    # Block 4: Indirect jumps
    for _ in range(indirect_len):
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op='JALR',
            valid=True,
            is_compressed=False,
            is_branch=True,
            is_taken=True,
            ex_valid=False
        ))
        pc += 4

    return instr_stream

def test_basic_functionality():
    """测试基本功能：正常指令处理和数据包生成"""
    print("\nTesting Basic Functionality")
    betr = BETR_Encoder(sram_max_len=4, trace_filename="test_basic_trace.txt")
    
    # 生成简单的指令流
    instr_stream = gen_instr_stream(normal_len=5, branch_len=2, trap_len=0, indirect_len=1)
    
    betr.set_enable(True)
    
    for i, instr in enumerate(instr_stream):
        print(f"Processing instruction {i+1}: PC=0x{instr.pc:08X}")
        betr.process_instr(instr)
    
    stats = betr.get_stats()
    print(f"Basic test completed: {stats['sram_packets']} packets generated")
    return betr

def test_stop_address_feature():
    """测试停止地址功能"""
    print("\n【STOP-ADDR】Testing Stop Address Feature")
    betr = BETR_Encoder(sram_max_len=4, trace_filename="test_stop_address_trace.txt")
    
    # 设置停止地址在中间位置
    stop_pc = 0x100C
    betr.set_stop_address(stop_pc, enable=True)
    betr.set_enable(True)
    
    instr_stream = gen_instr_stream(normal_len=10, branch_len=0, trap_len=0, indirect_len=0)
    
    irq_triggered = False
    for i, instr in enumerate(instr_stream):
        betr.process_instr(instr)
        if betr.irq_ctrl_reg.is_irq_active():
            print(f"【STOP-ADDR】Stop address IRQ triggered at PC=0x{instr.pc:08X}")
            irq_triggered = True
            break
    
    if not irq_triggered:
        print("【STOP-ADDR】Stop address IRQ was not triggered")
    
    return betr

def test_sram_full_condition():
    """测试SRAM满条件"""
    print("\n【STOP-ADDR】Testing SRAM Full Condition")
    betr = BETR_Encoder(sram_max_len=2, trace_filename="test_sram_full_trace.txt")
    betr.set_enable(True)
    
    instr_stream = gen_instr_stream(normal_len=2, branch_len=10, trap_len=0, indirect_len=0)
    
    for i, instr in enumerate(instr_stream[:8]):
        betr.process_instr(instr)
        if betr.irq_ctrl_reg.is_irq_active():
            print(f"【STOP-ADDR】SRAM full IRQ triggered after {i+1} instructions")
            break
    
    return betr

def test_encoder_enable_disable():
    """测试编码器启用/禁用功能"""
    print("\n【STOP-ADDR】Testing Encoder Enable/Disable")
    betr = BETR_Encoder(sram_max_len=4, trace_filename="test_enable_disable_trace.txt")
    
    instr_stream = gen_instr_stream(normal_len=10, branch_len=2, trap_len=0, indirect_len=0)
    
    # 阶段1: 禁用状态
    print("【STOP-ADDR】Phase 1: Encoder Disabled")
    betr.set_enable(False)
    for i in range(3):
        betr.process_instr(instr_stream[i])
    
    # 阶段2: 启用状态
    print("【STOP-ADDR】Phase 2: Encoder Enabled")
    betr.set_enable(True)
    for i in range(3, 6):
        betr.process_instr(instr_stream[i])
    
    # 阶段3: 再次禁用
    print("【STOP-ADDR】Phase 3: Encoder Disabled Again")
    betr.set_enable(False)
    for i in range(6, 8):
        betr.process_instr(instr_stream[i])
    
    stats = betr.get_stats()
    print(f"【STOP-ADDR】Enable/disable test completed: {stats['total_missed']} instructions missed")
    return betr

def test_comprehensive_scenario():
    """测试综合场景"""
    print("\nTesting Comprehensive Scenario")
    betr = BETR_Encoder(sram_max_len=4, trace_filename="test_comprehensive_trace.txt")
    
    betr.set_stop_address(0x1018, enable=True)
    instr_stream = gen_instr_stream(normal_len=8, branch_len=4, trap_len=1, indirect_len=2)
    
    print("Starting comprehensive test...")
    betr.set_enable(True)
    
    for i, instr in enumerate(instr_stream):
        print(f"Instruction {i+1}: PC=0x{instr.pc:08X}")
        betr.process_instr(instr)
        
        if betr.irq_ctrl_reg.is_irq_active():
            print("Stop address hit - clearing IRQ")
            betr.clear_irq()
            break
    
    return betr

def run_all_tests():
    """运行所有测试"""
    print("\n" + "=" * 70)
    print("BETR Encoder Test Suite")
    print("=" * 70)
    
    test_results = []
    test_functions = [
        test_basic_functionality,
        test_stop_address_feature, 
        test_sram_full_condition,
        test_encoder_enable_disable,
        test_comprehensive_scenario
    ]
    
    for test_func in test_functions:
        try:
            encoder = test_func()
            stats = encoder.get_stats()
            test_results.append({
                'test': test_func.__name__,
                'packets': stats['sram_packets'],
                'missed': stats['total_missed'],
                'status': 'PASS'
            })
        except Exception as e:
            test_results.append({
                'test': test_func.__name__, 
                'packets': 0,
                'missed': 0,
                'status': f'FAIL: {e}'
            })
    
    print("\n" + "=" * 70)
    print("Test Summary")
    print("=" * 70)
    for result in test_results:
        status_icon = "【STATUS】" if result['status'] == 'PASS' else "❌"
        print(f"{status_icon} {result['test']}: {result['status']}")
        print(f"   Packets: {result['packets']}, Missed: {result['missed']}")
    
    total = len(test_results)
    passed = sum(1 for r in test_results if r['status'] == 'PASS')
    print(f"\nTotal tests: {total}, Passed: {passed}, Failed: {total - passed}")


#####

## ===============================
## Example Usage
## ===============================
if __name__ == "__main__":
    print(f"\nTEST Finished.")
    
    #test_basic_functionality()

    # 方式：导入文件演示
    encoder = BETR_Encoder(sram_max_len=1000000,trace_filename="trace_signal_full.txt")
    encoder.trace_out.pkg_writer = TracePkgWriter("trace_pkg_only.txt")  # 保存纯包整数
    encoder.set_enable(True)
    
    #简易测试 10条指令coremark
    #encoder.import_and_process_log("../test/coremark/cva6_trace_log_for_test_10.log")

    #压力测试 全分支指令(pc不对的模拟版本)
    #encoder.import_and_process_log("../test/coremark/cva6_trace_log_for_test_allbr.log")

    #简易测试 8000条指令coremark
    #encoder.import_and_process_log("../test/coremark/cva6_trace_log_for_test_8000.log")

    #实际测试 全代码coremark
    #encoder.import_and_process_log("../test/coremark/cva6_trace_log_for_test.log")

    #简易测试 100条指令
    encoder.import_and_process_log("../test/coremark/cva6_trace_log_for_test_100_stack.log")