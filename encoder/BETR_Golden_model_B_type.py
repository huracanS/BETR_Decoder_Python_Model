## ===============================
## ä¸€ã€RVFI æ¥å£
## ===============================
class RVFI_Instr:
    """
    RVFI interface input instruction class
    """
    def __init__(self, pc, inst_op, valid,
                 is_compressed, is_branch, is_taken, ex_valid):
        self.valid = valid                   # æŒ‡ä»¤æœ‰æ•ˆä¿¡å·
        self.pc = pc                         # æŒ‡ä»¤åœ°å€
        self.inst_op = inst_op               # æŒ‡ä»¤ç±»å‹
        self.is_compressed = is_compressed   # æ˜¯å¦å‹ç¼©æŒ‡ä»¤
        self.is_branch = is_branch           # æ˜¯å¦è·³è½¬æŒ‡ä»¤
        self.is_taken = is_taken             # è·³è½¬æ˜¯å¦
        self.ex_valid = ex_valid             # æ˜¯å¦ä¸­æ–­æˆ–å¼‚å¸¸

## ===============================
## äºŒã€Trace åŒ…
## ===============================
class Trace_Pkg:
    """
    Trace packet generated by BETR encoder
    """
    def __init__(self, branch_addr, inst_cnt, br_tkn, extend=0):
        self.Branch_addr = branch_addr  # 32-bit æŒ‡ä»¤å—çš„èµ·å§‹åœ°å€
        self.inst_cnt = inst_cnt        # 10-bit æŒ‡ä»¤å—ä¸­æŒ‡ä»¤è®¡æ•°å€¼ 32bit + 2 ,16bit + 1
        self.Br_tkn = br_tkn            # 32-bit æŒ‡ä»¤å—ä¸­åˆ†æ”¯è·³è½¬ä¿¡æ¯
        self.extend = extend            # 1-bit  æ˜¯å¦ä¸­æ–­å¼‚å¸¸æ ‡å¿—ä½

    def to_int(self):
        """
        Pack trace packet into single integer (75-bit)
        Format: Branch_addr[31:0] + inst_cnt[9:0] + Br_tkn[31:0] + extend[0]
        """
        return (self.Branch_addr << (10 + 32 + 1)) | (self.inst_cnt << (32 + 1)) | (self.Br_tkn << 1) | self.extend

## ===============================
## ä¸‰ã€Logå¯¼å…¥ç³»ç»Ÿ
## ===============================

class LogFileImporter:
    """.logæ–‡ä»¶å¯¼å…¥å™¨"""
    
    def __init__(self):
        self.imported_data = []
    
    def import_log_file(self, filename):
        """
        å¯¼å…¥.logæ–‡ä»¶å¹¶è½¬æ¢ä¸ºRVFIæŒ‡ä»¤
        
        æ”¯æŒæ ¼å¼:
        valid:1,PC:0x00010000,Inst:0x00,is_branch:0,is_taken:0,is_compressed:0,ex_valid:0
        """
        self.imported_data = []
        
        try:
            with open(filename, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line or line.startswith("#") or line.startswith("Cycle"):
                        continue
                    
                    # è§£ææ•°æ®
                    instr = self._parse_log_line(line, line_num)
                    if instr:
                        self.imported_data.append(instr)
            
            print(f"æˆåŠŸå¯¼å…¥ {len(self.imported_data)} æ¡æŒ‡ä»¤æ¥è‡ª {filename}")
            return self.imported_data
            
        except FileNotFoundError:
            print(f"ã€ERRORã€‘æ–‡ä»¶æœªæ‰¾åˆ°: {filename}")
            return []
        except Exception as e:
            print(f"ã€ERRORã€‘å¯¼å…¥æ–‡ä»¶æ—¶å‡ºé”™: {e}")
            return []
    
    def _parse_log_line(self, line, line_num):
        """è§£æå•è¡Œæ—¥å¿—æ•°æ®"""
        try:
            data = {}
            pairs = line.split(',')
            
            for pair in pairs:
                if ':' in pair:
                    key, value = pair.split(':', 1)
                    data[key.strip()] = value.strip()
            
            # æ£€æŸ¥å¿…éœ€å­—æ®µ
            if 'valid' not in data or data['valid'] != '1':
                return None
            
            # åˆ›å»ºRVFIæŒ‡ä»¤å¯¹è±¡
            instr = RVFI_Instr(
                pc=int(data['PC'], 16) & 0xFFFFFFFF,           # 32ä½PC
                inst_op=int(data.get('Inst', '0'), 16) & 0xFF, # 8ä½æ“ä½œç 
                valid=True,
                is_compressed=data.get('is_compressed') == '1',
                is_branch=data.get('is_branch') == '1',
                is_taken=data.get('is_taken') == '1',
                ex_valid=data.get('ex_valid') == '1'
            )
            
            # # æ·»åŠ æ‰“å°å‘½ä»¤
            # print(f"RVFIæŒ‡ä»¤ä¿¡æ¯: PC=0x{instr.pc:08X}, æ“ä½œç =0x{instr.inst_op:02X}, "
            #     f"å‹ç¼©={instr.is_compressed}, åˆ†æ”¯={instr.is_branch}, "
            #     f"åˆ†æ”¯è·³è½¬={instr.is_taken}, æ˜¯å¦å¼‚å¸¸ä¸­æ–­={instr.ex_valid}")

            return instr
            
        except Exception as e:
            print(f"âš ï¸ ç¬¬ {line_num} è¡Œè§£æå¤±è´¥: {line} - {e}")
            return None
    
    def get_imported_data(self):
        """è·å–å¯¼å…¥çš„æ•°æ®"""
        return self.imported_data
    
    def clear_data(self):
        """æ¸…ç©ºå¯¼å…¥çš„æ•°æ®"""
        self.imported_data = []
        print("å·²æ¸…ç©ºå¯¼å…¥æ•°æ®")

##@@-- 20251103-Add File system
## ===============================
## å››ã€å‘é€æ•°æ®åŒ…å†™å…¥ç³»ç»Ÿ.
## ===============================
## Traceä¿¡å·æ–‡ä»¶è¾“å‡ºå™¨ï¼šä¿å­˜trace_validå’Œtrace_dataï¼ˆç”¨äºDEBUGæŸ¥çœ‹æ•°æ®åŒ…å†…å®¹ï¼‰.
class TraceSignalWriter:
    """Traceä¿¡å·æ–‡ä»¶è¾“å‡ºå™¨ - åªä¿å­˜trace_validå’Œtrace_data"""
    
    def __init__(self, filename="trace_signals.txt"):
        self.filename = filename
        
    def save_signal(self, trace_valid, branch_addr, inst_cnt, br_tkn, extend):
        """ä¿å­˜ä¿¡å·åˆ°æ–‡ä»¶ï¼Œæ ¼å¼ä¸ºå¯è¯»æ–‡æœ¬"""
        with open(self.filename, 'a') as f:
            line = (f"trace_valid:{trace_valid}, "
                    f"branch_addr:0x{branch_addr:08X}, "
                    f"inst_cnt:{inst_cnt}, "
                    f"br_tkn:0b{br_tkn:032b}, "
                    f"extend:{extend}\n")
            f.write(line)

# Traceä¿¡å·æ–‡ä»¶è¾“å‡ºå™¨ï¼šä¿å­˜trace_validå’Œtrace_dataï¼ˆå®Œæ•´æ ¼å¼ï¼Œç”¨äºè¾“å‡ºç»™è§£ç å™¨ï¼‰.
class TracePkgWriter:
    """ä¿å­˜traceåŒ…çš„çº¯æ•´æ•°ä¿¡æ¯"""
    def __init__(self, filename="trace_pkg_only.txt"):
        self.filename = filename
        with open(self.filename, 'w') as f:
            f.write("")  # æ¸…ç©ºæ–‡ä»¶

    def save_pkg(self, trace_pkg: Trace_Pkg):
        with open(self.filename, 'a') as f:
            f.write(f"{trace_pkg.to_int():019X}\n")
##@@-- 20251106-Add Package Saver.

## ===============================
## äº”ã€è¾“å‡ºæ–‡ä»¶ç³»ç»Ÿ
## ===============================
class Trace_Output:
    """
    Simulates BETR encoder output signals
    """
    def __init__(self,trace_filename = None, pkg_filename=None):
        self.trace_valid = 0
        self.trace_data = 0
        self.irq = 0
        
        ##@@-- 20251103-Add File system
        self.file_writer = None
        if trace_filename:
            self.file_writer = TraceSignalWriter(trace_filename)
            # å†™å…¥æ–‡ä»¶å¤´
            with open(trace_filename, 'w') as f:
                f.write("")
        ##@@-- 20251103-Add File system

        ##@@-- 20251106-Add Package Saver.
        self.pkg_writer = None
        if pkg_filename:
            self.pkg_writer = TracePkgWriter(pkg_filename)
            with open(pkg_filename, 'w') as f: f.write("")
        ##@@-- 20251106-Add Package Saver.

    def send(self, trace_pkg: Trace_Pkg, sram_full=False):
        """
        Send trace packet, update output signals, and print readable format
        """
        self.trace_data = trace_pkg.to_int()
        self.trace_valid = 1
        self.irq = 1 if sram_full else 0

        ##@@-- 20251103-Add File system
        if self.file_writer:
            self.file_writer.save_signal(
                trace_valid=self.trace_valid,
                branch_addr=trace_pkg.Branch_addr,
                inst_cnt=trace_pkg.inst_cnt,
                br_tkn=trace_pkg.Br_tkn,
                extend=trace_pkg.extend
            )
        ##@@-- 20251103-Add File system

        ##@@-- 20251106-Add Package Saver.
        if self.pkg_writer:
            self.pkg_writer.save_pkg(trace_pkg)
        ##@@-- 20251106-Add Package Saver.

        # Formatted print (green)
        print("\033[32m" + f"TRACE_VALID={self.trace_valid}, "
              f"Branch_addr=0x{trace_pkg.Branch_addr:08X}, "
              f"inst_cnt={trace_pkg.inst_cnt}, "
              f"Br_tkn={trace_pkg.Br_tkn:032b}, "
              f"extend={trace_pkg.extend}, "
              f"IRQ={self.irq}" + "\033[0m")


## ===============================
## å…­ã€æ§åˆ¶å¯„å­˜å™¨
## ===============================

# 1 - ä½¿èƒ½å¯„å­˜å™¨
class Control_Register:
    """
    Control register for enabling/disabling BETR encoder
    """
    def __init__(self, initial_value=0):
        self.ctrl_enable = initial_value  # 0: Disabled, 1: Enabled
    
    # ä½¿èƒ½BETRè¿½è¸ªåŠŸèƒ½
    def enable(self):
        """Enable encoder"""
        self.ctrl_enable = 1
        print("\033[33m BETR Encoder Enabled\033[0m")
    
    # å…³é—­BETRè¿½è¸ªåŠŸèƒ½
    def disable(self):
        """Disable encoder"""
        self.ctrl_enable = 0
        print("\033[33m BETR Encoder Disabled\033[0m")
    
    # æŸ¥çœ‹BETRæ˜¯å¦å¼€å¯
    def is_enabled(self):
        """Check if enabled"""
        return self.ctrl_enable == 1

# 2 - åœæ­¢åœ°å€å¯„å­˜å™¨
class Stop_Address_Register:
    """
    Stop address register, triggers interrupt when PC == stop_address
    """
    def __init__(self):
        self.stop_address = 0xFFFFFFFF  # Default: no stop address set
        self.enabled = 0                # Whether stop address feature is enabled
    
    def write(self, address, enable):
        """Write stop address and enable bit"""
        self.stop_address = address
        self.enabled = enable
        if enable:
            print(f"\033[36m STOP-ADDRESS: 0x{address:08X} (Enabled)\033[0m")
        else:
            print(f"\033[36m STOP-ADDRESS: Disabled\033[0m")
    
    def check_stop_address(self, pc):
        """Check if stop address is hit"""
        if self.enabled and pc == self.stop_address:
            print(f"\033[35m STOP-ADDRESS HIT! PC=0x{pc:08X}\033[0m")
            return True
        return False

# 3 - ä¸­æ–­æ§åˆ¶å¯„å­˜å™¨
class IRQ_Control_Register:
    """
    Interrupt control register for clearing interrupts
    """
    def __init__(self):
        self.irq_active = 0
    
    def set_irq(self):
        """Set interrupt"""
        self.irq_active = 1
    
    def clear_irq(self):
        """Clear interrupt"""
        self.irq_active = 0
        print("\033[36m IRQ Cleared\033[0m")
    
    def is_irq_active(self):
        """Check if interrupt is active"""
        return self.irq_active == 1

## ===============================
## ä¸ƒã€çŠ¶æ€å¯„å­˜å™¨
## ===============================
class Status_Register:
    """
    Status register holding current encoder state
    bit[0]: enable_status     - Encoder enable status (read-only)
    bit[1]: sram_full         - SRAM full status (read-only)  
    bit[2]: stop_address_hit  - Stop address hit (read-only)
    bit[3]: irq_pending       - Interrupt pending status (read-only)
    """
    def __init__(self):
        self.enable_status = 0      # bit0
        self.sram_full = 0          # bit1
        self.stop_address_hit = 0   # bit2  
        self.irq_pending = 0        # bit3  
    
    def read(self):
        """Read status register value"""
        return (self.irq_pending << 3) | (self.stop_address_hit << 2) | \
               (self.sram_full << 1) | self.enable_status
    
    def update_enable(self, enabled):
        """Update enable status"""
        self.enable_status = 1 if enabled else 0
    
    def update_sram_full(self, full):
        """Update SRAM full status"""
        self.sram_full = 1 if full else 0
    
    def set_stop_address_hit(self):
        """Set stop address hit flag"""
        self.stop_address_hit = 1
    
    def clear_stop_address_hit(self):
        """Clear stop address hit flag"""
        self.stop_address_hit = 0
    
    def set_irq_pending(self):
        """Set interrupt pending flag"""
        self.irq_pending = 1
    
    def clear_irq_pending(self):
        """Clear interrupt pending flag"""
        self.irq_pending = 0
    
    def __str__(self):
        """String representation for debugging"""
        status_bits = [
            f"ENABLE={self.enable_status}",
            f"SRAM_FULL={self.sram_full}",
            f"STOP_HIT={self.stop_address_hit}",
            f"IRQ_PENDING={self.irq_pending}"
        ]
        return f"STATUS[0x{self.read():02X}]: " + " | ".join(status_bits)




## ===============================
## å…«ã€æŒ‡ä»¤æ˜¯å¦å‹ç¼©
## ===============================
def is_compressed(instr: RVFI_Instr):
    """
    Check if instruction is 16-bit compressed
    """
    return instr.is_compressed  # Compressed instruction: last two bits != 11

## ===============================
## ä¹ã€æŒ‡ä»¤è¯†åˆ«ç±»å‹
## ===============================
def classify_instr(instr: RVFI_Instr):
    """
    Instruction classification:
    - NORMAL       : Normal instruction
    - BR_TAKEN     : Conditional branch taken  
    - BR_NOT_TKN   : Conditional branch not taken
    - INDIRECT     : Indirect jump (JALR)
    - TRAP         : Interrupt/exception
    - CALL         : CALL PUSH THE STACK
    - RETURN       : RETURN POP THE STACK
    """

    # Trap / exception
    if instr.ex_valid:
        return 'TRAP'

    # Indirect jump
    # åŒºåˆ†æˆä¸‰ç§é—´æ¥åˆ†æ”¯æŒ‡ä»¤ç±»å‹ï¼š
    #   è¿˜è¦è€ƒè™‘RETæŒ‡ä»¤ï¼ŒRETæŒ‡ä»¤æ˜¯ä»€ä¹ˆç±»å‹
    #   1.JALRï¼Œç›®æ ‡åœ°å€æ˜¯RETçš„ç±»å‹ï¼Œå½“ä½œé—´æ¥è·³è½¬åŒ…å¤„ç†å‘é€æ•°æ®åŒ…ï¼›
    #   2.JALRï¼Œç›®æ ‡åœ°å€ä¸æ˜¯RETçš„ç±»å‹ï¼Œæ‰§è¡Œå‹æ ˆæ“ä½œï¼›
    #   3.MRET/SRET/DRETï¼šè§†ä¸ºé—´æ¥è·³è½¬åŒ…å¤„ç†å‘é€æ•°æ®åŒ…ã€‚
    
    # # @TODO:Need to add CALL/RET Recognization.
    if instr.inst_op == 0x13:
        return 'INDIRECT'
    # # CALLã€RETURN
    # call_op = 
    # if instr.inst_op in indirect_ops:# MRET,SRET,DRET
    #     return 'CALL'
    # return_op = 
    # if instr.inst_op in indirect_ops:# MRET,SRET,DRET
    #     return 'RETURN'
    # # @TODO:Need to add CALL/RET Recognization.

    # MRETã€SRETã€DRET è§†ä¸ºä¸­æ–­çš„å¤„ç†æ–¹å¼
    indirect_ops = {0x17,0x18,0x19}
    if instr.inst_op in indirect_ops:# MRET,SRET,DRET
        return 'INDIRECT'

    # BranchæŒ‡ä»¤ åŒºåˆ†Takenå’ŒNot_Taken
    branch_ops = {0x11, 0x12, 0x0D, 0x0F, 0x0E, 0x10}  # EQ, NE, LTS, GES, LTU, GEU
    if instr.inst_op in branch_ops:
        if instr.is_taken:
            return 'BR_TAKEN'
        else:
            return 'BR_NOT_TAKEN'

    # æ™®é€šæŒ‡ä»¤
    return 'NORMAL'


## ===============================
## BETR Encoder Main Program
## ===============================
class BETR_Encoder:
    def __init__(self, sram_max_len=1024,trace_filename = None,stack_size=8):
        self.trace_out = Trace_Output(trace_filename)
        self.inst_cnt = 0
        self.br_cnt   = 0
        self.ctrl_reg = Control_Register(0)  # Default: disabled
        self.status_reg = Status_Register()  # Use new status register
        self.stop_addr_reg = Stop_Address_Register()  # Stop address register
        self.irq_ctrl_reg = IRQ_Control_Register()    # IRQ control register
        self.last_enable_state = 0    # Record previous enable state
        self.missed_instructions = 0  # Count missed instructions
        self.br_tkn = 0
        self.sram_buffer = []         # Simulate SRAM
        self.sram_max_len = sram_max_len
        self.sram_used = 0
        self.curr_branch_addr = None  # Current instruction block start address
        # +++ æ–°å¢ï¼šåŒ…ç±»å‹ç»Ÿè®¡ï¼ˆåŸºäºsend_reasonï¼‰+++
        self.pkg_type_stats = {
            'inst_cnt_max': 0,    # æŒ‡ä»¤è®¡æ•°æ»¡
            'br_tkn_full': 0,     # åˆ†æ”¯å†å²æ»¡
            'trap': 0,            # å¼‚å¸¸/ä¸­æ–­
            'indirect': 0,        # é—´æ¥è·³è½¬
            'normal': 0 ,          # æ­£å¸¸æŒ‡ä»¤å—
            'beat_tkn_full':0      #@@TODO():Test for Compressed Branch
        }

        ##@@20251106-Add CALL/RETURN Stack
        self.ret_stack = [0] * stack_size
        self.stack_size = stack_size
        self.head = 0  # å‹æ ˆæŒ‡é’ˆï¼ˆCALL å†™å…¥ï¼‰
        self.tail = 0  # å‡ºæ ˆæŒ‡é’ˆï¼ˆRET è¯»å‡ºï¼‰
        self.return_stack_addr = 0
        self.mis_stack = 0
        # ä¿å­˜ä¸Šä¸€æ‹çš„æŒ‡ä»¤ç±»å‹
        self.prev_instr_type   = None # ä¿å­˜ä¸Šä¸€æ‹çš„æŒ‡ä»¤ç±»å‹
        ##@@20251106-Add CALL/RETURN Stack

        ##@@20251106-Add Repeated Br
        self.prev_br_bit = None     # ä¿å­˜ä¸Šä¸€æ¡ br_tkn çš„ bitï¼ˆ1/0ï¼‰
        self.beat_tkn = 0
        self.beat_cnt = 0
        self.beat_break = 0
        self.repeat_cnt = 0         # é‡å¤æ¬¡æ•°
        self.B_value = 0            # å½“å‰é‡å¤çš„å€¼
        ##@@20251106-Add Repeated Br

    def reset(self):
        """Complete encoder reset"""
        self.inst_cnt = 0
        self.br_cnt   = 0
        self.br_tkn = 0
        self.sram_buffer = []
        self.sram_used = 0
        self.curr_branch_addr = None
        self.last_enable_state = 0
        self.missed_instructions = 0

        # +++ æ–°å¢ï¼šé‡ç½®åŒ…ç±»å‹ç»Ÿè®¡ +++
        for reason in self.pkg_type_stats:
            self.pkg_type_stats[reason] = 0

        self.ctrl_reg.disable()
        self.status_reg = Status_Register()
        self.stop_addr_reg = Stop_Address_Register()
        self.irq_ctrl_reg = IRQ_Control_Register()
        self.trace_out.irq = 0
        print("\033[36m BETR Encoder completely reset\033[0m")

    #@TODO:()
    ##@@20251106-Add CALL/RETURN Stack
    #1.å †æ ˆçš„å†™å…¥å’Œå¼¹å‡º
    def handle_call_ret(self, instr_type, return_addr):

        if instr_type == 'CALL':
            next_head = (self.head + 1) % self.stack_size
            if next_head == self.tail:
                print(f"âš ï¸ CALL stack overflow at return_addr=0x{return_addr:08X}")
                return
            self.ret_stack[self.head] = return_addr
            print(f"ğŸ”¹ CALL detected: return_addr=0x{return_addr:08X}")
            self.head = next_head

        elif instr_type == 'RETURN':
            next_head = (self.head + 1) % self.stack_size
            if self.head == self.tail:
                print("âš ï¸ RET with empty stack")
                return 0
            # å‡ºæ ˆï¼štail æŒ‡é’ˆä» head çš„å‰ä¸€ä¸ªä½ç½®å¼€å§‹
            self.head = (self.head - 1 + self.stack_size) % self.stack_size
            self.return_stack_addr = self.ret_stack[self.head]
            print(f"ğŸ”¹ RET detected: jump back to 0x{self.return_stack_addr:08X}")
            return self.return_stack_addr
        
    #2.å †æ ˆä¸¢å¤±ä¿¡æ¯åçš„å‡å°‘å’Œåˆ·æ–°

    #3.å †æ ˆé¢„æµ‹æ­£ç¡®æ€§çš„æ¯”è¾ƒ
    def check_return_address_is_miss(return_stack_addr,actual_addr):
        if(return_stack_addr == actual_addr) :
            print("æ ˆé¢„æµ‹è¿”å›åœ°å€æ­£ç¡®ï¼ï¼ï¼")
            return 0
        else :
            print("æ ˆé¢„æµ‹è¿”å›åœ°å€é”™è¯¯ï¼ï¼ï¼")
            return 1
        
    #4.å¯¼å‡ºå½“å‰æ ˆçŠ¶æ€ï¼ˆç”¨äºè°ƒè¯•æˆ–æ—¥å¿—ï¼‰
    def get_stack_status(self):
        print("ğŸ“‹ Current CALL/RET stack status:")
        print(f"  head={self.head}, tail={self.tail}")
        print(f"  stack contents={self.ret_stack}")
        return {
            'head': self.head,
            'tail': self.tail,
            'stack': self.ret_stack.copy()
        }
        
    ##@@20251106-Add CALL/RETURN Stack
    #@TODO:()

    # æŒ‡ä»¤è®¡ç®—çš„ä¸»å‡½æ•°
    def process_instr(self, instr: RVFI_Instr):
        if not instr.valid:
            return  # Ignore invalid instructions

        # If IRQ is already active (from previous stop address hit or SRAM full), skip processing
        if self.irq_ctrl_reg.is_irq_active():
            print(f"\033[90mInstruction PC=0x{instr.pc:08X} | IRQ active, skipping instruction\033[0m")
            return

        # Check stop address hit - triggers IRQ and stops processing
        if self.stop_addr_reg.check_stop_address(instr.pc):
            self._trigger_irq_stop_address()
            return  # Stop processing further instructions when stop address is hit

        # Detect enable state change
        current_enable = self.ctrl_reg.is_enabled()
        if self.last_enable_state == 0 and current_enable == 1:
            # Disabled â†’ Enabled: reset statistics, start new instruction block
            print(f"\033[35m Encoder enabled, starting new instruction block, PC=0x{instr.pc:08X}\033[0m")
            self.inst_cnt = 0
            self.br_tkn = 0
            self.curr_branch_addr = instr.pc
        elif self.last_enable_state == 1 and current_enable == 0:
            # Enabled â†’ Disabled: record state change
            print(f"\033[35m Encoder disabled, stopping statistics at PC=0x{instr.pc:08X}\033[0m")
            
        self.last_enable_state = current_enable

        # Check if encoder is enabled
        if not self.ctrl_reg.is_enabled():
            # Hardware real behavior: completely skip this instruction, no processing
            self.missed_instructions += 1
            print(f"\033[90mInstruction PC=0x{instr.pc:08X} | Encoder disabled, instruction missed (Total missed: {self.missed_instructions})\033[0m")
            return
            
        instr_type = classify_instr(instr)

        # Initialize current instruction block start address
        if self.curr_branch_addr is None:
            self.curr_branch_addr = instr.pc

        # #@TODO:()
        # #STACK 
        # ret_stack_addr = handle_call_ret()
        # # ä¸Šä¸€æ‹çš„æŒ‡ä»¤ç±»å‹ä¸ºRETURN
        # if prev_instr_type == 'RETURN':
            # å‡ºæ ˆå¹¶åˆ¤æ–­æ˜¯å¦æ­£ç¡®
            # handle_call_ret(self, prev_instr_type, instr.pc)
            # self.mis_stack = self.check_return_address_is_miss(ret_stack_addr,instr.pc)
        # elif instr_type == 'CALL'
            # å‹æ ˆ
            # handle_call_ret(self, instr_type, instr.pc)
        # #@TODO:()

        ##@@TODO:() New Branch
        self.New_branch_test(instr)
        ##@@TODO:() New Branch

        # Accumulate instruction length
        self.inst_cnt += 2 if not is_compressed(instr) else 1

        # Update br_tkn only valid for branch instructions
        if instr_type in ['BR_TAKEN', 'BR_NOT_TAKEN']:
            self.br_tkn = (self.br_tkn << 1) | (1 if instr_type == 'BR_TAKEN' else 0)
            self.br_cnt += 1

        # Extend bit, only valid for TRAP
        extend = 1 if instr_type == 'TRAP' else 0

        # Print each instruction information
        branch_addr_str = f"0x{self.curr_branch_addr:08X}" if self.curr_branch_addr is not None else "N/A"
        
        #CONFIG()æ‰“å°æ¯æ¡æŒ‡ä»¤ä¿¡æ¯
        print(f"Instruction PC=0x{instr.pc:08X} | Type={instr_type:12s} | "
              f"Compressed={'Yes(16bit)' if is_compressed(instr) else 'No(32bit)'} | "
              f"inst_cnt={self.inst_cnt:02d} | br_tkn={self.br_tkn:032b} | "
              f"branch_addr={branch_addr_str}")

        # Determine if trace packet should be sent
        send_flag, send_reason = self.should_send(instr)
        if send_flag:
            self._send_trace_packet(send_reason, extend)

        # -------- æ–°å¢ï¼šä¿å­˜ä¸Šä¸€æ‹æŒ‡ä»¤ç±»å‹ --------
        #@@TODO:()
        self.prev_instr_type = instr_type
    
    #@@TODO:()
    # æµ‹è¯•æ–°çš„bræ¨¡å¼
    def New_branch_test(self,instr):
        instr_type = classify_instr(instr)

        if instr_type in ['BR_TAKEN', 'BR_NOT_TAKEN']:
            curr_bit = 1 if instr_type == 'BR_TAKEN' else 0

            if self.prev_br_bit is None:
                # ç¬¬ä¸€æ¡åˆ†æ”¯
                self.prev_br_bit = curr_bit
                self.B_value     = curr_bit
                self.repeat_cnt  = 1
                print(
                    f"\033[33mCurr_pc=0x{instr.pc:08x} "
                    f"[STATE] prev_br_bit={self.prev_br_bit}, curr_bit={curr_bit}, "
                    f"B_value={self.B_value},"
                    f"repeat_cnt={self.repeat_cnt}, beat_break={self.beat_break}, "
                    f"beat_tkn={self.beat_tkn:032b}, beat_cnt={self.beat_cnt}\033[0m"
                )
                return
            
            if (curr_bit == self.prev_br_bit) and (self.repeat_cnt < 16) and (self.beat_break != 1):
                # è¿ç»­é‡å¤ï¼Œå¢åŠ é‡å¤è®¡æ•°
                self.repeat_cnt += 1
            else:
                self.beat_break = 1
                self.beat_tkn = (self.beat_tkn << 1) | curr_bit
                self.beat_cnt += 1

            self.prev_br_bit = curr_bit
            print(
                f"\033[33mCurr_pc=0x{instr.pc:08x} "
                f"[STATE] prev_br_bit={self.prev_br_bit}, curr_bit={curr_bit}, "
                f"B_value={self.B_value},"
                f"repeat_cnt={self.repeat_cnt}, beat_break={self.beat_break}, "
                f"beat_tkn={self.beat_tkn:032b}, beat_cnt={self.beat_cnt}\033[0m"
            )

        #@@TODO:()

    def _trigger_irq_stop_address(self):
        """Trigger IRQ due to stop address hit"""
        self.status_reg.set_stop_address_hit()
        self.irq_ctrl_reg.set_irq()
        self.status_reg.set_irq_pending()
        self.trace_out.irq = 1
        print("\033[31m Stop address hit, IRQ asserted - waiting for CLR_IRQ\033[0m")

    def _trigger_irq_sram_full(self):
        """Trigger IRQ due to SRAM full"""
        self.irq_ctrl_reg.set_irq()
        self.status_reg.set_irq_pending()
        self.trace_out.irq = 1
        print("\033[31m SRAM full, cannot send packet, IRQ asserted - waiting for CLR_IRQ\033[0m")

    def _send_trace_packet(self, send_reason, extend):
        """Send trace packet with proper IRQ handling"""
        sram_full = self.sram_used >= self.sram_max_len
        self.status_reg.update_sram_full(sram_full)  # Update SRAM full status
        
        if not sram_full:
            trace_pkg = Trace_Pkg(self.curr_branch_addr, self.inst_cnt, self.br_tkn, extend)

            # +++ æ–°å¢ï¼šåŸºäºsend_reasonæ›´æ–°åŒ…ç±»å‹ç»Ÿè®¡ +++
            if send_reason in self.pkg_type_stats:
                self.pkg_type_stats[send_reason] += 1
            else:
                self.pkg_type_stats['normal'] += 1  # é»˜è®¤å½’ä¸ºnormal

            print(f"ğŸ“¦ Trigger packet send: {send_reason}")
            self.trace_out.send(trace_pkg, sram_full=False)  # Always pass sram_full=False to send()
            self.sram_buffer.append(trace_pkg.to_int())
            self.sram_used += 1
            self.inst_cnt = 0
            self.br_cnt   = 0
            self.br_tkn = 0
            self.curr_branch_addr = None  # Reset for next block
            #@TODO:()
            self.prev_br_bit = None     # ä¿å­˜ä¸Šä¸€æ¡ br_tkn çš„ bitï¼ˆ1/0ï¼‰
            self.beat_tkn = 0
            self.beat_cnt = 0
            self.beat_break = 0
            self.repeat_cnt = 0         # é‡å¤æ¬¡æ•°
            self.B_value = 0            # å½“å‰é‡å¤çš„å€¼
            #@TODO:()
        else:
            self._trigger_irq_sram_full()

    def should_send(self, instr: RVFI_Instr):
        """
        Return: (whether to send packet, send reason)
        """
        instr_type = classify_instr(instr)
        if self.inst_cnt >= 1023:
            return True, 'inst_cnt_max'
        # if self.br_cnt >= 32: 
        #     return True, 'br_tkn_full'
        if instr.ex_valid == 1:
            return True, 'trap'
        #@TODO:()
        #if !self.mis_stack:
        #   return True, 'STACK_MISS'
        # å †æ ˆé¢„æµ‹å¤±è´¥åå‘åŒ…
        if self.beat_cnt >= 27:
            return True,'beat_tkn_full'
        # å‹ç¼©åŒ…æ¨¡å¼åˆ†æ”¯ä¿¡æ¯æ»¡
        #@TODO:()
        if instr_type == 'INDIRECT':
            return True, 'indirect'
        return False, ''

    def set_enable(self, enable):
        """Set encoder enable state"""
        if enable:
            self.ctrl_reg.enable()
            self.status_reg.update_enable(True)  # Update status register
        else:
            self.ctrl_reg.disable()
            self.status_reg.update_enable(False)  # Update status register

    def set_stop_address(self, address, enable=True):
        """Set stop address"""
        self.stop_addr_reg.write(address, enable)

    def clear_irq(self):
        """Clear interrupt - common for both SRAM full and stop address hit"""
        self.irq_ctrl_reg.clear_irq()
        self.status_reg.clear_irq_pending()
        self.status_reg.clear_stop_address_hit()  # Also clear stop address hit flag
        self.status_reg.update_sram_full(False)   # Also clear SRAM full status
        self.trace_out.irq = 0
        print("\033[36m All IRQ sources cleared (SRAM full + Stop address hit)\033[0m")

    def read_status(self):
        """Read status register"""
        return self.status_reg.read()

    def get_stats(self):
        """Get statistics"""
        return {
            "total_missed": self.missed_instructions,
            "sram_packets": len(self.sram_buffer),
            "current_enabled": self.ctrl_reg.is_enabled(),
            "status_register": self.status_reg.read(),
            "pkg_type_stats": self.pkg_type_stats.copy(),  # +++ æ–°å¢ï¼šåŒ…ç±»å‹ç»Ÿè®¡ ++
            "irq_active": self.irq_ctrl_reg.is_irq_active()
        }

    # +++ æ–°å¢æ–¹æ³•ï¼šæ‰“å°åŒ…ç±»å‹ç»Ÿè®¡ä¿¡æ¯ +++
    def print_package_statistics(self):
        """æ‰“å°åŒ…ç±»å‹ç»Ÿè®¡ä¿¡æ¯"""
        print("\n" + "="*60)
        print("ğŸ“Š TRACE PACKAGE TYPE STATISTICS")
        print("="*60)
        
        total_packets = sum(self.pkg_type_stats.values())
        if total_packets == 0:
            print("No trace packets generated yet.")
            return
        
        # å®šä¹‰ç±»å‹åç§°æ˜ å°„
        type_names = {
            'inst_cnt_max': "Instruction Count Max",
            'br_tkn_full': "Branch History Full", 
            'trap': "Traps/Exceptions",
            'indirect': "Indirect Jumps",
            'normal': "Normal Blocks",
            'beat_tkn_full':"beat_tkn_Full"
        }
        
        # æ‰“å°è¯¦ç»†ç»Ÿè®¡
        for reason in sorted(self.pkg_type_stats.keys()):
            count = self.pkg_type_stats[reason]
            percentage = (count / total_packets) * 100 if total_packets > 0 else 0
            type_name = type_names.get(reason, reason)
            
            print(f"  {type_name:<25}: {count:4d} packets ({percentage:6.2f}%)")
        
        print("-"*60)
        print(f"  {'TOTAL':<25}: {total_packets:4d} packets (100.00%)")
        print("="*60)

    def import_and_process_log(self, log_filename):
        """
        å¯¼å…¥.logæ–‡ä»¶å¹¶ç«‹å³å¤„ç†
        
        Args:
            log_filename: .logæ–‡ä»¶è·¯å¾„
        """
        importer = LogFileImporter()
        instructions = importer.import_log_file(log_filename)
        
        if not instructions:
            print("âŒ æ²¡æœ‰å¯å¤„ç†çš„æŒ‡ä»¤")
            return
        
        print(f"ğŸš€ å¼€å§‹å¤„ç† {len(instructions)} æ¡æŒ‡ä»¤...")
        
        # å¤„ç†æ‰€æœ‰å¯¼å…¥çš„æŒ‡ä»¤
        for i, instr in enumerate(instructions):
            # CONFIG()å¤„ç†æ‰€æœ‰çš„æŒ‡ä»¤
            #print(f"å¤„ç†æŒ‡ä»¤ {i+1}/{len(instructions)}: PC=0x{instr.pc:08X}")
            self.process_instr(instr)
        
        # è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
        stats = self.get_stats()
        print(f"\nâœ… å¤„ç†å®Œæˆ")
        print(f"   - ç”Ÿæˆæ•°æ®åŒ…: {stats['sram_packets']}")
        print(f"   - ä¸¢å¤±æŒ‡ä»¤: {stats['total_missed']}")
        print(f"   - å‹ç¼©ç‡: {1 - stats['sram_packets']/len(instructions):.2%}")

        # +++ æ–°å¢ï¼šæ‰“å°åŒ…ç±»å‹ç»Ÿè®¡ +++
        self.print_package_statistics()



#####
## ===============================
## Test Functions for New BETR Encoder Interface
## ===============================
def gen_instr_stream(normal_len=4, branch_len=2, trap_len=1, indirect_len=1, start_pc=0x00001000):
    instr_stream = []
    pc = start_pc

    # Block 1: Normal instructions
    for _ in range(normal_len):
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op=0x00,       # æ™®é€šæŒ‡ä»¤
            valid=True,
            is_compressed=False,
            is_branch=False,
            is_taken=False,
            ex_valid=False
        ))
        pc += 4

    # Block 2: Branch instructions
    branch_ops = ['EQ', 'NE', 'LTS', 'GES', 'LTU', 'GEU']
    for i in range(branch_len):
        op = branch_ops[i % len(branch_ops)]
        taken = (i % 2 == 0)
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op=op,
            valid=True,
            is_compressed=False,
            is_branch=True,
            is_taken=taken,
            ex_valid=False
        ))
        pc += 4

    # Block 3: Trap instructions
    for _ in range(trap_len):
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op=0x00,  # ä»»æ„æ“ä½œç 
            insn=0x00000093,
            valid=True,
            is_compressed=False,
            is_branch=False,
            is_taken=False,
            ex_valid=True
        ))
        pc += 4

    # Block 4: Indirect jumps
    for _ in range(indirect_len):
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op='JALR',
            valid=True,
            is_compressed=False,
            is_branch=True,
            is_taken=True,
            ex_valid=False
        ))
        pc += 4

    return instr_stream

def test_basic_functionality():
    """æµ‹è¯•åŸºæœ¬åŠŸèƒ½ï¼šæ­£å¸¸æŒ‡ä»¤å¤„ç†å’Œæ•°æ®åŒ…ç”Ÿæˆ"""
    print("\nTesting Basic Functionality")
    betr = BETR_Encoder(sram_max_len=4, trace_filename="test_basic_trace.txt")
    
    # ç”Ÿæˆç®€å•çš„æŒ‡ä»¤æµ
    instr_stream = gen_instr_stream(normal_len=5, branch_len=2, trap_len=0, indirect_len=1)
    
    betr.set_enable(True)
    
    for i, instr in enumerate(instr_stream):
        print(f"Processing instruction {i+1}: PC=0x{instr.pc:08X}")
        betr.process_instr(instr)
    
    stats = betr.get_stats()
    print(f"Basic test completed: {stats['sram_packets']} packets generated")
    return betr

def test_stop_address_feature():
    """æµ‹è¯•åœæ­¢åœ°å€åŠŸèƒ½"""
    print("\nğŸ§ª Testing Stop Address Feature")
    betr = BETR_Encoder(sram_max_len=4, trace_filename="test_stop_address_trace.txt")
    
    # è®¾ç½®åœæ­¢åœ°å€åœ¨ä¸­é—´ä½ç½®
    stop_pc = 0x100C
    betr.set_stop_address(stop_pc, enable=True)
    betr.set_enable(True)
    
    instr_stream = gen_instr_stream(normal_len=10, branch_len=0, trap_len=0, indirect_len=0)
    
    irq_triggered = False
    for i, instr in enumerate(instr_stream):
        betr.process_instr(instr)
        if betr.irq_ctrl_reg.is_irq_active():
            print(f"Stop address IRQ triggered at PC=0x{instr.pc:08X}")
            irq_triggered = True
            break
    
    if not irq_triggered:
        print("Stop address IRQ was not triggered")
    
    return betr

def test_sram_full_condition():
    """æµ‹è¯•SRAMæ»¡æ¡ä»¶"""
    print("\nTesting SRAM Full Condition")
    betr = BETR_Encoder(sram_max_len=2, trace_filename="test_sram_full_trace.txt")
    betr.set_enable(True)
    
    instr_stream = gen_instr_stream(normal_len=2, branch_len=10, trap_len=0, indirect_len=0)
    
    for i, instr in enumerate(instr_stream[:8]):
        betr.process_instr(instr)
        if betr.irq_ctrl_reg.is_irq_active():
            print(f"SRAM full IRQ triggered after {i+1} instructions")
            break
    
    return betr

def test_encoder_enable_disable():
    """æµ‹è¯•ç¼–ç å™¨å¯ç”¨/ç¦ç”¨åŠŸèƒ½"""
    print("\nTesting Encoder Enable/Disable")
    betr = BETR_Encoder(sram_max_len=4, trace_filename="test_enable_disable_trace.txt")
    
    instr_stream = gen_instr_stream(normal_len=10, branch_len=2, trap_len=0, indirect_len=0)
    
    # é˜¶æ®µ1: ç¦ç”¨çŠ¶æ€
    print("Phase 1: Encoder Disabled")
    betr.set_enable(False)
    for i in range(3):
        betr.process_instr(instr_stream[i])
    
    # é˜¶æ®µ2: å¯ç”¨çŠ¶æ€
    print("Phase 2: Encoder Enabled")
    betr.set_enable(True)
    for i in range(3, 6):
        betr.process_instr(instr_stream[i])
    
    # é˜¶æ®µ3: å†æ¬¡ç¦ç”¨
    print("Phase 3: Encoder Disabled Again")
    betr.set_enable(False)
    for i in range(6, 8):
        betr.process_instr(instr_stream[i])
    
    stats = betr.get_stats()
    print(f"Enable/disable test completed: {stats['total_missed']} instructions missed")
    return betr

def test_comprehensive_scenario():
    """æµ‹è¯•ç»¼åˆåœºæ™¯"""
    print("\nTesting Comprehensive Scenario")
    betr = BETR_Encoder(sram_max_len=4, trace_filename="test_comprehensive_trace.txt")
    
    betr.set_stop_address(0x1018, enable=True)
    instr_stream = gen_instr_stream(normal_len=8, branch_len=4, trap_len=1, indirect_len=2)
    
    print("Starting comprehensive test...")
    betr.set_enable(True)
    
    for i, instr in enumerate(instr_stream):
        print(f"Instruction {i+1}: PC=0x{instr.pc:08X}")
        betr.process_instr(instr)
        
        if betr.irq_ctrl_reg.is_irq_active():
            print("Stop address hit - clearing IRQ")
            betr.clear_irq()
            break
    
    return betr

def run_all_tests():
    """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
    print("\n" + "=" * 70)
    print("BETR Encoder Test Suite")
    print("=" * 70)
    
    test_results = []
    test_functions = [
        test_basic_functionality,
        test_stop_address_feature, 
        test_sram_full_condition,
        test_encoder_enable_disable,
        test_comprehensive_scenario
    ]
    
    for test_func in test_functions:
        try:
            encoder = test_func()
            stats = encoder.get_stats()
            test_results.append({
                'test': test_func.__name__,
                'packets': stats['sram_packets'],
                'missed': stats['total_missed'],
                'status': 'PASS'
            })
        except Exception as e:
            test_results.append({
                'test': test_func.__name__, 
                'packets': 0,
                'missed': 0,
                'status': f'FAIL: {e}'
            })
    
    print("\n" + "=" * 70)
    print("Test Summary")
    print("=" * 70)
    for result in test_results:
        status_icon = "ã€STATUSã€‘" if result['status'] == 'PASS' else "âŒ"
        print(f"{status_icon} {result['test']}: {result['status']}")
        print(f"   Packets: {result['packets']}, Missed: {result['missed']}")
    
    total = len(test_results)
    passed = sum(1 for r in test_results if r['status'] == 'PASS')
    print(f"\nTotal tests: {total}, Passed: {passed}, Failed: {total - passed}")


#####

## ===============================
## Example Usage
## ===============================
if __name__ == "__main__":
    print(f"\nTEST Finished.")
    
    #test_basic_functionality()

    # æ–¹å¼ï¼šå¯¼å…¥æ–‡ä»¶æ¼”ç¤º
    encoder = BETR_Encoder(sram_max_len=1000000,trace_filename="trace_signal_full.txt")
    encoder.trace_out.pkg_writer = TracePkgWriter("trace_pkg_only.txt")  # ä¿å­˜çº¯åŒ…æ•´æ•°
    encoder.set_enable(True)
    
    #ç®€æ˜“æµ‹è¯• 10æ¡æŒ‡ä»¤coremark
    #encoder.import_and_process_log("../test/coremark/cva6_trace_log_for_test_10.log")

    #ç®€æ˜“æµ‹è¯• 400æ¡æŒ‡ä»¤coremark
    #encoder.import_and_process_log("../test/coremark/cva6_trace_log_for_test_400.log")

    #ç®€æ˜“æµ‹è¯• 8000æ¡æŒ‡ä»¤coremark
    encoder.import_and_process_log("../test/coremark/cva6_trace_log_for_test_8000.log")

    #å‹åŠ›æµ‹è¯• å…¨åˆ†æ”¯æŒ‡ä»¤(pcä¸å¯¹çš„æ¨¡æ‹Ÿç‰ˆæœ¬)
    #encoder.import_and_process_log("../test/coremark/cva6_trace_log_for_test_allbr.log")

    #å®é™…æµ‹è¯• å…¨ä»£ç coremark
    #encoder.import_and_process_log("../test/coremark/cva6_trace_log_for_test.log")
