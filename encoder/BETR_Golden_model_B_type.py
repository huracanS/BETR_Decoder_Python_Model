## ===============================
## 一、RVFI 接口
## ===============================
class RVFI_Instr:
    """
    RVFI interface input instruction class
    """
    def __init__(self, pc, inst_op, valid,
                 is_compressed, is_branch, is_taken, ex_valid, inst_code, rd_reg, rs1_reg,rs2_reg):
        self.valid = valid                   # 指令有效信号
        self.pc = pc                         # 指令地址
        self.inst_op = inst_op               # 指令类型
        self.is_compressed = is_compressed   # 是否压缩指令
        self.is_branch = is_branch           # 是否跳转指令
        self.is_taken = is_taken             # 跳转是否
        self.ex_valid = ex_valid             # 是否中断或异常

        #@@TODO():Add Stack Signals
        self.inst_code = inst_code # 指令的全部指令（From RVFI）
        self.rd_reg    = rd_reg # 指令的目的寄存器
        self.rs1_reg    = rs1_reg # 指令的源寄存器1
        self.rs2_reg    = rs2_reg # 指令的源寄存器2
        #@@TODO():Add Stack Signals

## ===============================
## 二、Trace 包
## ===============================
class Trace_Pkg:
    """
    Trace packet generated by BETR encoder
    """
    def __init__(self, branch_addr, inst_cnt, br_tkn, extend=0):
        self.Branch_addr = branch_addr  # 32-bit 指令块的起始地址
        self.inst_cnt = inst_cnt        # 10-bit 指令块中指令计数值 32bit + 2 ,16bit + 1
        self.Br_tkn = br_tkn            # 32-bit 指令块中分支跳转信息
        self.extend = extend            # 1-bit  是否中断异常标志位

    def to_int(self):
        """
        Pack trace packet into single integer (75-bit)
        Format: Branch_addr[31:0] + inst_cnt[9:0] + Br_tkn[31:0] + extend[0]
        """
        return (self.Branch_addr << (10 + 32 + 1)) | (self.inst_cnt << (32 + 1)) | (self.Br_tkn << 1) | self.extend

## ===============================
## 三、Log导入系统
## ===============================

class LogFileImporter:
    """.log文件导入器"""
    
    def __init__(self):
        self.imported_data = []
    
    def import_log_file(self, filename):
        """
        导入.log文件并转换为RVFI指令
        
        支持格式:
        valid:1,PC:0x00010000,Inst:0x00,is_branch:0,is_taken:0,is_compressed:0,ex_valid:0
        """
        self.imported_data = []
        try:
            with open(filename, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line or line.startswith("#") or line.startswith("Cycle"):
                        continue
                    # 解析数据
                    instr = self._parse_log_line(line, line_num)
                    if instr:
                        self.imported_data.append(instr)
            print(f"成功导入 {len(self.imported_data)} 条指令来自 {filename}")
            return self.imported_data
        except FileNotFoundError:
            print(f"【ERROR】文件未找到: {filename}")
            return []
        except Exception as e:
            print(f"【ERROR】导入文件时出错: {e}")
            return []
    
    def _parse_log_line(self, line, line_num):
        """解析单行日志数据"""
        try:
            data = {}
            pairs = line.split(',')
            
            for pair in pairs:
                if ':' in pair:
                    key, value = pair.split(':', 1)
                    data[key.strip()] = value.strip()
            
            # 检查必需字段
            if 'valid' not in data or data['valid'] != '1':
                return None
            
            # 创建RVFI指令对象
            instr = RVFI_Instr(
                pc=int(data['PC'], 16) & 0xFFFFFFFF,           # 32位PC
                inst_op=int(data.get('Inst', '0'), 16) & 0xFF, # 8位操作码
                valid=True,
                is_compressed=data.get('is_compressed') == '1',
                is_branch=data.get('is_branch') == '1',
                is_taken=data.get('is_taken') == '1',
                ex_valid=data.get('ex_valid') == '1',
                #@@TODO():Add Stack Signals
                rd_reg=int(data.get('rd_register', '0'), 16),
                rs1_reg=int(data.get('rs1_register', '0'), 16),
                rs2_reg=int(data.get('rs2_register', '0'), 16),
                inst_code=int(data.get('inst_code', '0'), 16)
                #@@TODO():Add Stack Signals
            )
            

            # 添加打印命令
            print(f"RVFI指令信息: PC=0x{instr.pc:08X}, 操作码=0x{instr.inst_op:02X}, "
                f"压缩={instr.is_compressed}, 分支={instr.is_branch}, "
                f"分支跳转={instr.is_taken}, 是否异常中断={instr.ex_valid}"
                f"目的寄存器=0x{instr.rd_reg:02x},源寄存器1=0x{instr.rs1_reg:02x},源寄存器2=0x{instr.rs2_reg:02x}"
                f"指令全码=0x{instr.inst_code:08x}"
                )
            return instr
        except Exception as e:
            print(f"【ERROR】第 {line_num} 行解析失败: {line} - {e}")
            return None
    
    def get_imported_data(self):
        """获取导入的数据"""
        return self.imported_data
    
    def clear_data(self):
        """清空导入的数据"""
        self.imported_data = []
        print("已清空导入数据")

##@@-- 20251103-Add File system
## ===============================
## 四、发送数据包写入系统.
## ===============================
## Trace信号文件输出器：保存trace_valid和trace_data（用于DEBUG查看数据包内容）.
class TraceSignalWriter:
    """Trace信号文件输出器 - 只保存trace_valid和trace_data"""
    
    def __init__(self, filename="trace_signals.txt"):
        self.filename = filename
        
    def save_signal(self, trace_valid, branch_addr, inst_cnt, br_tkn, extend):
        """保存信号到文件，格式为可读文本"""
        with open(self.filename, 'a') as f:
            line = (f"trace_valid:{trace_valid}, "
                    f"branch_addr:0x{branch_addr:08X}, "
                    f"inst_cnt:{inst_cnt}, "
                    f"br_tkn:0b{br_tkn:032b}, "
                    f"extend:{extend}\n")
            f.write(line)

# Trace信号文件输出器：保存trace_valid和trace_data（完整格式，用于输出给解码器）.
class TracePkgWriter:
    """保存trace包的纯整数信息"""
    def __init__(self, filename="trace_pkg_only.txt"):
        self.filename = filename
        with open(self.filename, 'w') as f:
            f.write("")  # 清空文件

    def save_pkg(self, trace_pkg: Trace_Pkg):
        with open(self.filename, 'a') as f:
            f.write(f"{trace_pkg.to_int():019X}\n")
##@@-- 20251106-Add Package Saver.

## ===============================
## 五、输出文件系统
## ===============================
class Trace_Output:
    """
    Simulates BETR encoder output signals
    """
    def __init__(self,trace_filename = None, pkg_filename=None):
        self.trace_valid = 0
        self.trace_data = 0
        self.irq = 0
        
        #Trace信号文件输出
        self.file_writer = None
        if trace_filename:
            self.file_writer = TraceSignalWriter(trace_filename)
            # 写入文件头
            with open(trace_filename, 'w') as f:
                f.write("")

        #Trace包整数输出
        self.pkg_writer = None
        if pkg_filename:
            self.pkg_writer = TracePkgWriter(pkg_filename)
            with open(pkg_filename, 'w') as f: f.write("")

    def send(self, trace_pkg: Trace_Pkg, sram_full=False):
        """
        Send trace packet, update output signals, and print readable format
        """
        self.trace_data = trace_pkg.to_int()
        self.trace_valid = 1
        self.irq = 1 if sram_full else 0

        ##@@-- 20251103-Add File system
        if self.file_writer:
            self.file_writer.save_signal(
                trace_valid=self.trace_valid,
                branch_addr=trace_pkg.Branch_addr,
                inst_cnt=trace_pkg.inst_cnt,
                br_tkn=trace_pkg.Br_tkn,
                extend=trace_pkg.extend
            )
        ##@@-- 20251103-Add File system

        ##@@-- 20251106-Add Package Saver.
        if self.pkg_writer:
            self.pkg_writer.save_pkg(trace_pkg)
        ##@@-- 20251106-Add Package Saver.

        # Formatted print (green)
        print("\033[32m" + f"TRACE_VALID={self.trace_valid}, "
              f"Branch_addr=0x{trace_pkg.Branch_addr:08X}, "
              f"inst_cnt={trace_pkg.inst_cnt}, "
              f"Br_tkn={trace_pkg.Br_tkn:032b}, "
              f"extend={trace_pkg.extend}, "
              f"IRQ={self.irq}" + "\033[0m")


## ===============================
## 六、控制寄存器
## ===============================

# 1 - 使能寄存器
class Control_Register:
    """
    Control register for enabling/disabling BETR encoder
    """
    def __init__(self, initial_value=0):
        self.ctrl_enable = initial_value  # 0: Disabled, 1: Enabled
    
    # 使能BETR追踪功能
    def enable(self):
        """Enable encoder"""
        self.ctrl_enable = 1
        print("\033[33m BETR Encoder Enabled\033[0m")
    
    # 关闭BETR追踪功能
    def disable(self):
        """Disable encoder"""
        self.ctrl_enable = 0
        print("\033[33m BETR Encoder Disabled\033[0m")
    
    # 查看BETR是否开启
    def is_enabled(self):
        """Check if enabled"""
        return self.ctrl_enable == 1

# 2 - 停止地址寄存器
class Stop_Address_Register:
    """
    Stop address register, triggers interrupt when PC == stop_address
    """
    def __init__(self):
        self.stop_address = 0xFFFFFFFF  # Default: no stop address set
        self.enabled = 0                # Whether stop address feature is enabled
    
    def write(self, address, enable):
        """Write stop address and enable bit"""
        self.stop_address = address
        self.enabled = enable
        if enable:
            print(f"\033[36m STOP-ADDRESS: 0x{address:08X} (Enabled)\033[0m")
        else:
            print(f"\033[36m STOP-ADDRESS: Disabled\033[0m")
    
    def check_stop_address(self, pc):
        """Check if stop address is hit"""
        if self.enabled and pc == self.stop_address:
            print(f"\033[35m STOP-ADDRESS HIT! PC=0x{pc:08X}\033[0m")
            return True
        return False

# 3 - 中断控制寄存器
class IRQ_Control_Register:
    """
    Interrupt control register for clearing interrupts
    """
    def __init__(self):
        self.irq_active = 0
    
    def set_irq(self):
        """Set interrupt"""
        self.irq_active = 1
    
    def clear_irq(self):
        """Clear interrupt"""
        self.irq_active = 0
        print("\033[36m IRQ Cleared\033[0m")
    
    def is_irq_active(self):
        """Check if interrupt is active"""
        return self.irq_active == 1

## ===============================
## 七、状态寄存器
## ===============================
class Status_Register:
    """
    Status register holding current encoder state
    bit[0]: enable_status     - Encoder enable status (read-only)
    bit[1]: sram_full         - SRAM full status (read-only)  
    bit[2]: stop_address_hit  - Stop address hit (read-only)
    bit[3]: irq_pending       - Interrupt pending status (read-only)
    """
    def __init__(self):
        self.enable_status = 0      # bit0
        self.sram_full = 0          # bit1
        self.stop_address_hit = 0   # bit2  
        self.irq_pending = 0        # bit3  
    
    def read(self):
        """Read status register value"""
        return (self.irq_pending << 3) | (self.stop_address_hit << 2) | \
               (self.sram_full << 1) | self.enable_status
    
    def update_enable(self, enabled):
        """Update enable status"""
        self.enable_status = 1 if enabled else 0
    
    def update_sram_full(self, full):
        """Update SRAM full status"""
        self.sram_full = 1 if full else 0
    
    def set_stop_address_hit(self):
        """Set stop address hit flag"""
        self.stop_address_hit = 1
    
    def clear_stop_address_hit(self):
        """Clear stop address hit flag"""
        self.stop_address_hit = 0
    
    def set_irq_pending(self):
        """Set interrupt pending flag"""
        self.irq_pending = 1
    
    def clear_irq_pending(self):
        """Clear interrupt pending flag"""
        self.irq_pending = 0
    
    def __str__(self):
        """String representation for debugging"""
        status_bits = [
            f"ENABLE={self.enable_status}",
            f"SRAM_FULL={self.sram_full}",
            f"STOP_HIT={self.stop_address_hit}",
            f"IRQ_PENDING={self.irq_pending}"
        ]
        return f"STATUS[0x{self.read():02X}]: " + " | ".join(status_bits)

## ===============================
## 九、指令识别类型
## ===============================
def classify_instr(instr: RVFI_Instr):
    """
    Instruction classification:
    - NORMAL       : Normal instruction
    - BR_TAKEN     : Conditional branch taken  
    - BR_NOT_TKN   : Conditional branch not taken
    - INDIRECT     : Indirect jump (JALR)
    - TRAP         : Interrupt/exception
    - CALL         : CALL PUSH THE STACK
    - RETURN       : RETURN POP THE STACK
    """

    # Trap / exception
    if instr.ex_valid:
        return 'TRAP'

    # Indirect jump
    # 区分成三种间接分支指令类型：
    #   还要考虑RET指令，RET指令是什么类型
    #   1.JALR，C.JALR,目标地址是RET的类型，当作间接跳转包处理发送数据包；
    #   2.JALR，目标地址不是RET的类型，执行压栈操作；
    #   3.MRET/SRET/DRET：视为间接跳转包处理发送数据包。
    
    ###TODO():
    # # @TODO:Need to add CALL/RET Recognization.
    
    # JAL指令
    #因为CVA6没有识别对应JAL的指令类型，所以加入额外的逻辑识别对应指令。
    #32bit
    stack_rd = [0x01,0x05] # X1和X5链接寄存器,x0是JAL
    call_op = 0x6F 
    if ((instr.inst_code & 0x7F) == call_op) and (instr.rd_reg in stack_rd):# MRET,SRET,DRET
        return 'CALL'
    # 16-bit compressed JAL (C.JAL) seen as CALL
    instr16 = instr.inst_code & 0xFFFF  # 取低16位
    if instr.is_compressed:  # 低两位 != 0b11 表示压缩指令
        # 是16-bit压缩指令
        funct3 = (instr16 >> 13) & 0x7
        if funct3 == 0b001:  # C.JAL
            return 'CALL'
    
    # JALR指令
    if instr.inst_op == 0x13:
        rd_is_x1_x5 = instr.rd_reg in stack_rd
        rs_is_x1_x5 = instr.rs1_reg in stack_rd

        if not rd_is_x1_x5 and not rs_is_x1_x5:
            return 'INDIRECT'       # 普通间接跳转
        elif not rd_is_x1_x5 and rs_is_x1_x5:
            return 'RETURN'     # ret: jalr x0, 0(x1)
        elif rd_is_x1_x5 and not rs_is_x1_x5:
            return 'CALL'       # call: jalr x1, offset(x2)
        elif rd_is_x1_x5 and rs_is_x1_x5 and instr.rd_reg != instr.rs1_reg:
            return 'COROUTINE'  # coroutine: jalr x1, offset(x5)
        elif rd_is_x1_x5 and rs_is_x1_x5 and instr.rd_reg == instr.rs1_reg:
            return 'SELF_CALL'  # jalr x1, offset(x1)
        else:
            return 'INDIRECT'

    # CVA6已经对MRET、SRET、DRET进行标识，这里将其视为中断的处理方式
    indirect_ops = {0x17,0x18,0x19}
    if instr.inst_op in indirect_ops:# MRET,SRET,DRET
        return 'INDIRECT'

    # Branch指令 区分Taken和Not_Taken
    branch_ops = {0x11, 0x12, 0x0D, 0x0F, 0x0E, 0x10}  # EQ, NE, LTS, GES, LTU, GEU
    if instr.inst_op in branch_ops:
        if instr.is_taken:
            return 'BR_TAKEN'
        else:
            return 'BR_NOT_TAKEN'

    # 普通指令
    return 'NORMAL'


# ============================================================
#  Module: BETR Encoder
#  Description: 
#       BETR（BES TRACE)模块用于从处理器流水线中采集指令级跟踪信息并压缩为追踪包；
#       用于实现嵌入式、低功耗的信息追踪系统；
#       将一个追踪包发送的起止指令记为一个指令块，支持：
#           支持计数满后触发发送追踪包；
#           支持中断异常包触发发送追踪包；
#           支持CALL/RETURN 栈预测，减少RETURN类的间接跳转追踪包数量，当堆栈缺失后触发发送追踪包；
#           支持记录指令块分支跳转信息满后触发发送追踪包。【压缩分支功能:正在开发压缩分支功能，减少分支信息满发送的追踪包。】
#       增加寄存器控制追踪开启、停止地址、触发CPU中断、停止中断的功能。
#  Date: 2025-11-06
#  Sub_function:
#      MAIN Functions - 主功能函数
#          1. __init__()                       : 初始化 BETR 编码器核心状态、寄存器、SRAM、统计计数器
#          2. reset()                          : 完全复位编码器，包括栈、寄存器与统计信息
#          3. process_instr(instr)             : 主指令处理函数，执行指令分类、状态更新与打包判断
#
#      CALL/RETURN Stack Management - 
#          4. handle_call_ret(instr_type, addr): 实现 CALL/RETURN/COROUTINE 指令的堆栈压入与弹出逻辑
#          5. check_return_address_is_miss(...) : 检查返回地址预测是否正确，检测栈预测失配
#          6. get_stack_status()               : 输出当前栈的 head/tail 状态与内容（调试用）
#
#      Branch Compression & Pattern Analysis 
#          7. New_branch_test(instr)           : 新分支压缩模式测试（重复次数与跳变检测） #TODO()：设计还存在问题
#
#      Trace Packet Control -
#          8. should_send(instr)               : 判断是否满足打包条件并返回原因
#          9. _send_trace_packet(reason, ext)  : 构建并发送追踪包，更新统计与状态
#
#      Interrupt & Stop Address Handling -
#         10. _trigger_irq_stop_address()      : 当检测到停止地址命中时触发 IRQ
#         11. _trigger_irq_sram_full()         : 当 SRAM 已满时触发 IRQ 并暂停发送
#         12. clear_irq()                      : 清除所有中断标志（SRAM/Stop Address）
#
#      Register & Status Management -
#         13. set_enable(enable)               : 设置编码器使能状态并更新状态寄存器
#         14. set_stop_address(address, en)    : 写入停止地址寄存器
#         15. read_status()                    : 读取当前状态寄存器值
#
#      Statistics & Debug Utilities -
#         16. get_stats()                      : 获取编码器统计信息（包类型、使能状态、IRQ等）
#         17. print_package_statistics()       : 打印追踪包类型统计表（占比、计数、类别）
#         18. import_and_process_log(file)     : 导入 .log 指令文件进行实际代码测试并逐条处理生成追踪结果
# ============================================================
class BETR_Encoder:
    def __init__(self, sram_max_len=1024,trace_filename = None,stack_size=4):
        """Initialize BETR Encoder"""
        
        # 基础计数
        self.trace_out = Trace_Output(trace_filename) # 初始化输出模块
        self.inst_cnt = 0  #指令计数
        self.br_cnt   = 0  #分支指令计数(BR_taken + BR_Not_taken)
        self.br_tkn = 0    #分支跳转情况

        # 控制寄存器
        self.ctrl_reg = Control_Register(0)           # 默认：关闭使能寄存器
        self.last_enable_state = 0                    # 用于记录上一拍的enable从而控制使能寄存器的开启与关闭
        self.status_reg = Status_Register()           # 使用状态控制寄存器
        self.stop_addr_reg = Stop_Address_Register()  # 停止地址寄存器
        self.irq_ctrl_reg = IRQ_Control_Register()    # 中断控制寄存器
        self.missed_instructions = 0                  # 模拟真实硬件错过执行指令的数量

        # SRAM模拟
        self.sram_buffer = []            # 初始化SRAM
        self.sram_max_len = sram_max_len #SRAM的最大深度
        self.sram_used = 0               #SRAM已经写入的数量
        self.curr_branch_addr = None     # Current instruction block start address

        # 包类型统计（基于Send_reason)
        self.pkg_type_stats = {
            'inst_cnt_max': 0,     # 指令计数满
            'br_tkn_full': 0,      # 分支信息满
            'trap': 0,             # 异常/中断
            'indirect': 0,         # 间接跳转
            'normal': 0 ,          # 正常指令块
            'stack_miss': 0,       # CALL RETURN Stack缺失
            'beat_tkn_full':0      # #TODO():压缩BR分支信息满
        }

        # CALL/RETURN Stack管理
        ##@@20251106-Add CALL/RETURN Stack
        self.ret_stack = [0] * stack_size # 初始化栈
        self.stack_size = stack_size      # 栈的最大深度
        self.head = 0                     # 压栈指针（CALL 写入）
        self.tail = 0                     # 出栈指针（RET 读出）
        self.return_stack_addr = 0        # 出栈的返回数据
        self.mis_stack = 0                # 栈访问缺失的情况 返回地址不等于实际要跳转地址
        self.prev_instr_type   = None     # 保存上一拍的指令类型
        ##@@20251106-Add CALL/RETURN Stack

        ##@@20251106-Add Repeated Br
        self.prev_br_bit = None     # 保存上一条 br_tkn 的 bit（1/0）
        self.beat_tkn = 0           # 压缩后剩余的跳转信息
        self.beat_cnt = 0           # 压缩后剩余的跳转信息次数
        self.beat_break = 0         # 第一次不连续打破压缩
        self.repeat_cnt = 0         # 重复次数
        self.B_value = 0            # 当前压缩重复的值
        ##@@20251106-Add Repeated Br

    def reset(self):
        """Complete encoder reset"""
        self.inst_cnt = 0
        self.br_cnt   = 0
        self.br_tkn = 0
        self.sram_buffer = []
        self.sram_used = 0
        self.curr_branch_addr = None
        self.last_enable_state = 0
        self.missed_instructions = 0

        # 重置包类型统计
        for reason in self.pkg_type_stats:
            self.pkg_type_stats[reason] = 0
        
        # 寄存器重置
        self.ctrl_reg.disable()
        self.status_reg = Status_Register()
        self.stop_addr_reg = Stop_Address_Register()
        self.irq_ctrl_reg = IRQ_Control_Register()
        self.trace_out.irq = 0

        # CALL/RETURN Stack 重置
        self.ret_stack = [0] * self.stack_size
        self.head = 0
        self.tail = 0
        self.return_stack_addr = 0
        self.mis_stack = 0
        self.prev_instr_type = None

        # Repeated Br 重置
        self.prev_br_bit = None
        self.beat_tkn = 0
        self.beat_cnt = 0
        self.beat_break = 0
        self.repeat_cnt = 0
        self.B_value = 0

        print("\033[36m BETR Encoder completely reset\033[0m")

    ##@@20251106-Add CALL/RETURN Stack

    # ======================================================
    # 1、handle_call_ret函数: 处理 CALL/ SELF_CALL/ RETURN / COROUTINE 指令的堆栈操作
    # ======================================================
    def handle_call_ret(self, instr_type, return_addr):
        """处理 CALL / RETURN / COROUTINE 指令的堆栈操作,返回 (是否命中堆栈, 返回地址)"""
        print(f"Instr_type = {instr_type} 【STACK】Stack operation detected: {instr_type}")

        # ------------------------------------------------------
        # CALL / SELF_CALL: 压入返回地址
        # ----------------------------------------------------
        if instr_type == 'CALL' or instr_type == 'SELF_CALL':
            next_head = (self.head + 1) % self.stack_size
            if next_head == self.tail:
                # Stack 已满，丢弃最老的 CALL（tail 指向的）
                print(f"【STACK】CALL stack full, discard oldest at 0x{self.ret_stack[self.tail]:08X}")
                self.tail = (self.tail + 1) % self.stack_size  # tail 前移，腾出空间
                # 注意这里不 return，继续压入新 CALL

            # 压入新 CALL
            self.ret_stack[self.head] = return_addr
            print(f"【STACK】CALL push → return_addr=0x{return_addr:08X}, head={self.head}->{next_head}")
            self.head = next_head
            return 0,0

        # ------------------------------------------------------
        # RETURN: 弹出返回地址
        # ------------------------------------------------------
        elif instr_type == 'RETURN':
            if self.head == self.tail:
                print("【STACK】RET with empty stack")
                return 0,0
            else:
                # 出栈：tail 指针从 head 的前一个位置开始
                self.head = (self.head - 1 + self.stack_size) % self.stack_size
                self.return_stack_addr = self.ret_stack[self.head]
                # 清空已弹出的栈数据（可选，但调试推荐）
                self.ret_stack[self.head] = 0
                print(f"【STACK】RETURN pop ← jump_back=0x{self.return_stack_addr:08X}, head={self.head}")
                return 1,self.return_stack_addr
        
        # ------------------------------------------------------
        # COROUTINE: 先弹出（如果非空）再压入
        # ------------------------------------------------------
        elif instr_type == 'COROUTINE':
            # POP（如果栈非空）
            if self.head != self.tail:
                self.head = (self.head - 1 + self.stack_size) % self.stack_size
                self.ret_stack[self.head] = 0
                print(f"【STACK】COROUTINE pop ← old_addr cleared, head={self.head}")
            else:
                print(f"【STACK】COROUTINE pop skipped, stack empty")

            # PUSH
            self.ret_stack[self.head] = return_addr
            self.head = (self.head + 1) % self.stack_size
            print(f"【STACK】COROUTINE push → return_addr=0x{return_addr:08X}, head={self.head}")
            return 0,0

        # ------------------------------------------------------
        # 非 CALL/SELF_CALL/RETURN/COROUTINE 指令，不处理
        # ------------------------------------------------------
        else:
            return 0,0
    
    # ======================================================
    # TODO():2、堆栈丢失信息后的减少和刷新，针对SRAM overwrite添加堆栈信息的刷新
    # ======================================================
    #2.堆栈丢失信息后的减少和刷新
    
    # ======================================================
    # 3、check_return_address_is_miss函数: 堆栈预测正确性比较
    # ======================================================
    """比较堆栈预测返回地址与实际跳转地址；返回 0 表示预测正确，1 表示预测错误"""
    def check_return_address_is_miss(self,instr_type,return_stack_addr,actual_addr):
        print(f"[STACK-DEBUG] type={instr_type}, head={self.head}, tail={self.tail}")
        print("[STACK-DEBUG] stack=[" + ", ".join(f"0x{x:08X}" for x in self.ret_stack) + "]")

        if(return_stack_addr == actual_addr) :
            print("栈预测返回地址正确！！！")
            return 0
        else :
            print("栈预测返回地址错误！！！")
            print(f"【STACK-MISS】 return_addr=0x{return_stack_addr:08X}, actual=0x{actual_addr:08X}")
            return 1
    
    # ======================================================
    # 4、get_stack_status函数: 导出当前栈状态（用于调试或日志）
    # ======================================================
    """返回当前栈状态，包括 head、tail 和 stack 内容"""
    def get_stack_status(self):
        print("【STACK】Current CALL/RET stack status:")
        print(f"  head={self.head}, tail={self.tail}")
        print(f"  stack contents={self.ret_stack}")
        return {
            'head': self.head,
            'tail': self.tail,
            'stack': self.ret_stack.copy()
        }
    ##@@20251106-Add CALL/RETURN Stack


    # ======================================================
    # process_instr函数: 指令计算的主函数
    # ======================================================
    def process_instr(self, instr: RVFI_Instr):
        """处理单条指令，更新指令计数、分支信息、CALL/RETURN堆栈，并决定是否发送TRACE包"""
        # --------------------------------------------------
        # Step 1: 忽略无效指令
        # --------------------------------------------------
        if not instr.valid:
            return

        # --------------------------------------------------
        # Step 2: IRQ控制寄存器检查，如果已经被触发，则跳过指令
        # ------------------------------------------------
        # If IRQ is already active (from previous stop address hit or SRAM full), skip processing
        if self.irq_ctrl_reg.is_irq_active():
            print(f"\033[90m Instruction PC=0x{instr.pc:08X} | IRQ active, skipping instruction\033[0m")
            return
        
        # --------------------------------------------------
        # Step 3: Stop address命中检查，触发IRQ
        # --------------------------------------------------
        if self.stop_addr_reg.check_stop_address(instr.pc):
            self._trigger_irq_stop_address()
            return

        # --------------------------------------------------
        # Step 4: Enable状态变化检测
        # --------------------------------------------------
        current_enable = self.ctrl_reg.is_enabled()
        if self.last_enable_state == 0 and current_enable == 1:
            # Disabled → Enabled: reset statistics, start new instruction block
            print(f"\033[35m Encoder enabled, starting new instruction block, PC=0x{instr.pc:08X}\033[0m")
            self.inst_cnt = 0
            self.br_tkn = 0
            self.curr_branch_addr = instr.pc
        elif self.last_enable_state == 1 and current_enable == 0:
            # Enabled → Disabled: record state change
            print(f"\033[35m Encoder disabled, stopping statistics at PC=0x{instr.pc:08X}\033[0m")
            
        self.last_enable_state = current_enable


        # --------------------------------------------------
        # Step 5: 如果Encoder被禁用，记录missed指令并跳过
        # Hardware real behavior: completely skip this instruction, no processing
        # --------------------------------------------------
        if not self.ctrl_reg.is_enabled():
            self.missed_instructions += 1
            print(f"\033[90m Instruction PC=0x{instr.pc:08X} | Encoder disabled, instruction missed (Total missed: {self.missed_instructions})\033[0m")
            return
        
        # --------------------------------------------------
        # Step 6: 指令分类
        # --------------------------------------------------
        instr_type = classify_instr(instr)

        # --------------------------------------------------
        # Step 7: 首条指令地址初始化为指令块的地址
        # --------------------------------------------------
        if self.curr_branch_addr is None:
            self.curr_branch_addr = instr.pc

        # --------------------------------------------------
        # Step 8: CALL/RETURN堆栈处理
        # --------------------------------------------------
        next_pc = instr.pc + (2 if instr.is_compressed else 4)

        if self.prev_instr_type == 'RETURN':
            ret_stack_hit,ret_stack_addr = self.handle_call_ret('RETURN', next_pc)
            self.mis_stack = self.check_return_address_is_miss('RETURN',ret_stack_addr,instr.pc)
        elif instr_type == 'CALL' or instr_type == 'SELF_CALL':
            #压栈
            stack_hit,ret_stack_addr = self.handle_call_ret('CALL', next_pc)
        elif instr_type == 'COROUTINE':
            ret_stack_hit,ret_stack_addr = self.handle_call_ret('COROUTINE', next_pc)
            self.mis_stack = self.check_return_address_is_miss('COROUTINE',ret_stack_addr,instr.pc)
        #@TODO:()

        # --------------------------------------------------
        # Step 9: New Branch测试（压缩BR）
        # --------------------------------------------------
        ##@@TODO:() New Branch
        self.New_branch_test(instr)

        # --------------------------------------------------
        # Step 10: 更新指令计数和分支信息
        # --------------------------------------------------
        self.inst_cnt += 1 if instr.is_compressed else 2

        # Update br_tkn only valid for branch instructions
        if instr_type in ['BR_TAKEN', 'BR_NOT_TAKEN']:
            self.br_tkn = (self.br_tkn << 1) | (1 if instr_type == 'BR_TAKEN' else 0)
            self.br_cnt += 1

        # Extend bit, only valid for TRAP
        extend = 1 if instr_type == 'TRAP' else 0

        # Print each instruction information #CONFIG()打印每条指令信息
        branch_addr_str = f"0x{self.curr_branch_addr:08X}" if self.curr_branch_addr is not None else "N/A"
        print(f"Instruction PC=0x{instr.pc:08X} | Type={instr_type:12s} | "
              f"Compressed={'Yes(16bit)' if instr.is_compressed else 'No(32bit)'} | "
              f"inst_cnt={self.inst_cnt:02d} | br_tkn={self.br_tkn:032b} | "
              f"branch_addr={branch_addr_str}")

        # --------------------------------------------------
        # Step 10: 判断是否发送TRACE包
        # --------------------------------------------------
        send_flag, send_reason = self.should_send(instr) # 发送信号和发送标识.
        if send_flag:
            self._send_trace_packet(send_reason, extend)

        # --------------------------------------------------
        # Step 11: 保存上一拍指令类型 for RETURN类型，利用上一拍类型是RETURN，发送RETURN信息和真实跳转地址进行比较.
        # --------------------------------------------------
        self.prev_instr_type = instr_type
    
    #@@TODO:()
    # ======================================================
    # New_branch_test函数: 测试新的BR压缩模式
    # ======================================================
    def New_branch_test(self,instr):
        instr_type = classify_instr(instr)

        if instr_type in ['BR_TAKEN', 'BR_NOT_TAKEN']:
            curr_bit = 1 if instr_type == 'BR_TAKEN' else 0

            # --------------------------------------------------
            # Step 1: 第一条分支初始化
            # --------------------------------------------------
            if self.prev_br_bit is None:
                # 第一条分支
                self.prev_br_bit = curr_bit
                self.B_value     = curr_bit
                self.repeat_cnt  = 1
                print(
                    f"\033[33mCurr_pc=0x{instr.pc:08x} "
                    f"[STATE] prev_br_bit={self.prev_br_bit}, curr_bit={curr_bit}, "
                    f"B_value={self.B_value},"
                    f"repeat_cnt={self.repeat_cnt}, beat_break={self.beat_break}, "
                    f"beat_tkn={self.beat_tkn:032b}, beat_cnt={self.beat_cnt}\033[0m"
                )
                return
            
            # --------------------------------------------------
            # Step 2: 重复BR处理
            # --------------------------------------------------
            if (curr_bit == self.prev_br_bit) and (self.repeat_cnt < 16) and (self.beat_break != 1):
                # 连续重复，增加重复计数
                self.repeat_cnt += 1
            else:
                self.beat_break = 1
                self.beat_tkn = (self.beat_tkn << 1) | curr_bit
                self.beat_cnt += 1

            self.prev_br_bit = curr_bit
            print(
                f"\033[33mCurr_pc=0x{instr.pc:08x} "
                f"[STATE] prev_br_bit={self.prev_br_bit}, curr_bit={curr_bit}, "
                f"B_value={self.B_value},"
                f"repeat_cnt={self.repeat_cnt}, beat_break={self.beat_break}, "
                f"beat_tkn={self.beat_tkn:032b}, beat_cnt={self.beat_cnt}\033[0m"
            )
        #@@TODO:()

    # ======================================================
    # IRQ触发函数：Stop Address
    # ======================================================
    def _trigger_irq_stop_address(self):
        """Trigger IRQ due to stop address hit"""
        self.status_reg.set_stop_address_hit()
        self.irq_ctrl_reg.set_irq()
        self.status_reg.set_irq_pending()
        self.trace_out.irq = 1
        print("\033[31m Stop address hit, IRQ asserted - waiting for CLR_IRQ\033[0m")

    # ======================================================
    # IRQ触发函数：SRAM Full
    # ======================================================
    def _trigger_irq_sram_full(self):
        """Trigger IRQ due to SRAM full"""
        self.irq_ctrl_reg.set_irq()
        self.status_reg.set_irq_pending()
        self.trace_out.irq = 1
        print("\033[31m SRAM full, cannot send packet, IRQ asserted - waiting for CLR_IRQ\033[0m")

    # ======================================================
    # TRACE包发送函数
    # ======================================================
    def _send_trace_packet(self, send_reason, extend):
        """
        Send trace packet with proper SRAM and STACK handling

        Args:
            send_reason: 触发发送的原因
            extend: TRAP扩展标志
        """
        # --------------------------------------------------
        # Step 1: 检查SRAM是否满
        # --------------------------------------------------
        sram_full = self.sram_used >= self.sram_max_len
        self.status_reg.update_sram_full(sram_full)  # Update SRAM full status
        
        if sram_full:
            self._trigger_irq_sram_full()
            return

        # --------------------------------------------------
        # Step 2: 构建TRACE包
        # --------------------------------------------------
        trace_pkg = Trace_Pkg(self.curr_branch_addr, self.inst_cnt, self.br_tkn, extend)

        # +++ 新增：基于send_reason更新包类型统计 +++
        if send_reason in self.pkg_type_stats:
            self.pkg_type_stats[send_reason] += 1
        else:
            self.pkg_type_stats['normal'] += 1  # 默认归为normal

        print(f"【PACKAGE】Trigger packet send: {send_reason}")
        self.trace_out.send(trace_pkg, sram_full=False)  # Always pass sram_full=False to send()
        self.sram_buffer.append(trace_pkg.to_int())
        self.sram_used += 1

        # --------------------------------------------------
        # Step 3: 清理指令计数、分支信息和状态
        # --------------------------------------------------
        self.inst_cnt = 0
        self.br_cnt   = 0
        self.br_tkn = 0
        self.curr_branch_addr = None  # Reset for next block

        #@TODO:() 重置BR压缩状态
        self.prev_br_bit = None     
        self.beat_tkn = 0
        self.beat_cnt = 0
        self.beat_break = 0
        self.repeat_cnt = 0         # 重复次数
        self.B_value = 0            # 当前重复的值
        #@TODO:()

        ##@@TODO():
        ##@@20251106-Add CALL/RETURN Stack
        # # 发包后清空STACK.
        # self.ret_stack = [0] * self.stack_size
        # self.stack_size = self.stack_size
        # self.head = 0  # 压栈指针（CALL 写入）
        # self.tail = 0  # 出栈指针（RET 读出）
        # self.return_stack_addr = 0
        # 清空STACK_MISS情况.
        self.mis_stack = 0
        # 保存上一拍的指令类型
        self.prev_instr_type   = None # 保存上一拍的指令类型
        ##@@20251106-Add CALL/RETURN Stack
        ##@@TODO():

    def should_send(self, instr: RVFI_Instr):
        """
        Return: (whether to send packet, send reason)
        """
        instr_type = classify_instr(instr)
        # 1.指令计数满 inst_cnt >= 1023
        if self.inst_cnt >= 1023:
            return True, 'inst_cnt_max'
        # 2.分支信息满 原始分支跳转信息，深度为32
        # if self.br_cnt >= 32: 
        #     return True, 'br_tkn_full'
        # 3.中断异常触发
        if instr.ex_valid == 1:
            return True, 'trap'
        #@TODO:() 3.CALL/RETURN STACK的构建，堆栈预测失败后发包
        if self.mis_stack == 1:
          return True, 'stack_miss'
        # 4.分支信息满 压缩分支跳转信息，深度最大为2^5 + 27
        if self.beat_cnt >= 27:
            return True,'beat_tkn_full'
        # 压缩包模式分支信息满
        #@TODO:()
        if instr_type == 'INDIRECT':
            return True, 'indirect'
        return False, ''

    # ======================================================
    # Encoder Enable / Stop Address / IRQ Clear
    # ======================================================
    def set_enable(self, enable):
        """Set encoder enable state"""
        if enable:
            self.ctrl_reg.enable()
            self.status_reg.update_enable(True)  # Update status register
        else:
            self.ctrl_reg.disable()
            self.status_reg.update_enable(False)  # Update status register

    def set_stop_address(self, address, enable=True):
        """Set stop address"""
        self.stop_addr_reg.write(address, enable)

    def clear_irq(self):
        """Clear interrupt - common for both SRAM full and stop address hit"""
        self.irq_ctrl_reg.clear_irq()
        self.status_reg.clear_irq_pending()
        self.status_reg.clear_stop_address_hit()  # Also clear stop address hit flag
        self.status_reg.update_sram_full(False)   # Also clear SRAM full status
        self.trace_out.irq = 0
        print("\033[36m All IRQ sources cleared (SRAM full + Stop address hit)\033[0m")

    # ======================================================
    # Status / Statistics
    # ======================================================
    def read_status(self):
        """Read status register"""
        return self.status_reg.read()

    def get_stats(self):
        """Get statistics"""
        return {
            "total_missed": self.missed_instructions,
            "sram_packets": len(self.sram_buffer),
            "current_enabled": self.ctrl_reg.is_enabled(),
            "status_register": self.status_reg.read(),
            "pkg_type_stats": self.pkg_type_stats.copy(),  # +++ 新增：包类型统计 ++
            "irq_active": self.irq_ctrl_reg.is_irq_active()
        }

    # +++ 新增方法：打印包类型统计信息 +++
    def print_package_statistics(self):
        """打印包类型统计信息"""
        print("\n" + "="*60)
        print("【PACKAGE】TRACE PACKAGE TYPE STATISTICS")
        print("="*60)
        
        total_packets = sum(self.pkg_type_stats.values())
        if total_packets == 0:
            print("No trace packets generated yet.")
            return
        
        # 定义类型名称映射
        type_names = {
            'inst_cnt_max': "Instruction Count Max",
            'br_tkn_full': "Branch History Full", 
            'trap': "Traps/Exceptions",
            'indirect': "Indirect Jumps",
            'normal': "Normal Blocks",
            'stack_miss': "Stack Miss",
            'beat_tkn_full':"beat_tkn_Full"
        }
        
        # 打印详细统计
        for reason in sorted(self.pkg_type_stats.keys()):
            count = self.pkg_type_stats[reason]
            percentage = (count / total_packets) * 100 if total_packets > 0 else 0
            type_name = type_names.get(reason, reason)
            
            print(f"  {type_name:<25}: {count:4d} packets ({percentage:6.2f}%)")
        
        print("-"*60)
        print(f"  {'TOTAL':<25}: {total_packets:4d} packets (100.00%)")
        print("="*60)

    # ======================================================
    # 导入并处理.log文件代码
    # ======================================================
    def import_and_process_log(self, log_filename):
        """
        导入.log文件并立即处理
        
        Args:
            log_filename: .log文件路径
        """
        importer = LogFileImporter()
        instructions = importer.import_log_file(log_filename)
        
        if not instructions:
            print("【ERROR】没有可处理的指令")
            return
        
        print(f"【START】开始处理 {len(instructions)} 条指令...")
        
        # 处理所有导入的指令
        for i, instr in enumerate(instructions):
            # CONFIG()处理所有的指令
            #print(f"处理指令 {i+1}/{len(instructions)}: PC=0x{instr.pc:08X}")
            self.process_instr(instr)
        
        # 输出统计信息
        stats = self.get_stats()
        print(f"\n【FINISH】处理完成")
        print(f"   - 生成数据包: {stats['sram_packets']}")
        print(f"   - 丢失指令: {stats['total_missed']}")
        print(f"   - 压缩率: {1 - stats['sram_packets']/len(instructions):.2%}")

        # +++ 新增：打印包类型统计 +++
        self.print_package_statistics()



#####
## ===============================
## Test Functions for New BETR Encoder Interface
## ===============================
def gen_instr_stream(normal_len=4, branch_len=2, trap_len=1, indirect_len=1, start_pc=0x00001000):
    instr_stream = []
    pc = start_pc

    # Block 1: Normal instructions
    for _ in range(normal_len):
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op=0x00,       # 普通指令
            valid=True,
            is_compressed=False,
            is_branch=False,
            is_taken=False,
            ex_valid=False,
            # 添加参数 CALL/RETURN
            inst_code  = 0,# 指令的全部指令（From RVFI）
            rd_reg     = 0,# 指令的目的寄存器
            rs1_reg    = 0,# 指令的源寄存器1
            rs2_reg    = 0 # 指令的源寄存器2
        ))
        pc += 4

    # Block 2: Branch instructions
    branch_ops = [0x11, 0x12, 0x0D, 0x0F, 0x0E, 0x10]  # EQ, NE, LTS, GES, LTU, GEU
    for i in range(branch_len):
        op = branch_ops[i % len(branch_ops)]
        taken = (i % 2 == 0)
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op=op,
            valid=True,
            is_compressed=False,
            is_branch=True,
            is_taken=taken,
            ex_valid=False,
            # 添加参数 CALL/RETURN
            inst_code  = 0,# 指令的全部指令（From RVFI）
            rd_reg     = 0,# 指令的目的寄存器
            rs1_reg    = 0,# 指令的源寄存器1
            rs2_reg    = 0 # 指令的源寄存器2
        ))
        pc += 4

    # Block 3: Trap instructions
    for _ in range(trap_len):
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op=0x00,  # 任意操作码
            insn=0x00000093,
            valid=True,
            is_compressed=False,
            is_branch=False,
            is_taken=False,
            ex_valid=True,
            # 添加参数 CALL/RETURN
            inst_code  = 0,# 指令的全部指令（From RVFI）
            rd_reg     = 0,# 指令的目的寄存器
            rs1_reg    = 0,# 指令的源寄存器1
            rs2_reg    = 0 # 指令的源寄存器2
        ))
        pc += 4

    # Block 4: Indirect jumps
    for _ in range(indirect_len):
        instr_stream.append(RVFI_Instr(
            pc=pc,
            inst_op=0x13,
            valid=True,
            is_compressed=False,
            is_branch=True,
            is_taken=True,
            ex_valid=False,
            # 添加参数 CALL/RETURN
            inst_code  = 0,# 指令的全部指令（From RVFI）
            rd_reg     = 0,# 指令的目的寄存器
            rs1_reg    = 0,# 指令的源寄存器1
            rs2_reg    = 0 # 指令的源寄存器2
        ))
        pc += 4

    return instr_stream

def test_basic_functionality():
    """测试基本功能：正常指令处理和数据包生成"""
    print("\nTesting Basic Functionality")
    betr = BETR_Encoder(sram_max_len=4, trace_filename="test_basic_trace.txt")
    
    # 生成简单的指令流
    instr_stream = gen_instr_stream(normal_len=5, branch_len=2, trap_len=0, indirect_len=1)
    
    betr.set_enable(True)
    
    for i, instr in enumerate(instr_stream):
        print(f"Processing instruction {i+1}: PC=0x{instr.pc:08X}")
        betr.process_instr(instr)
    
    stats = betr.get_stats()
    print(f"Basic test completed: {stats['sram_packets']} packets generated")
    return betr

def test_stop_address_feature():
    """测试停止地址功能，确保 IRQ 触发两次并可清零"""
    print("\n【STOP】Testing Stop Address Feature")
    betr = BETR_Encoder(sram_max_len=4, trace_filename="test_stop_address_trace.txt")
    
    # 第一次停止地址
    first_stop_pc = 0x100C
    betr.set_stop_address(first_stop_pc, enable=True)
    betr.set_enable(True)
    
    # 生成指令流（第一次停止地址出现）
    instr_stream = gen_instr_stream(normal_len=12, branch_len=0, trap_len=0, indirect_len=0)
    
    irq_count = 0
    for i, instr in enumerate(instr_stream):
        betr.process_instr(instr)
        
        if betr.irq_ctrl_reg.is_irq_active():
            irq_count += 1
            print(f"【STOP】Stop address IRQ triggered at PC=0x{instr.pc:08X}, count={irq_count}")
            betr.clear_irq()
            print(f"【STOP】IRQ cleared")
            
            # 更新停止地址为第二次触发
            if irq_count == 1:
                second_stop_pc = 0x1020
                betr.set_stop_address(second_stop_pc, enable=True)
                print(f"【STOP】Stop address updated to 0x{second_stop_pc:08X}")
    
    print(f"Total IRQ triggers: {irq_count}")
    return betr

def test_sram_full_condition():
    """测试SRAM满条件"""
    print("\nTesting SRAM Full Condition")
    betr = BETR_Encoder(sram_max_len=2, trace_filename="test_sram_full_trace.txt")
    betr.set_enable(True)
    
    instr_stream = gen_instr_stream(normal_len=2, branch_len=10, trap_len=0, indirect_len=5)
    
    for i, instr in enumerate(instr_stream):
        betr.process_instr(instr)
        if betr.irq_ctrl_reg.is_irq_active():
            print(f"SRAM full IRQ triggered after {i+1} instructions")
            break
    
    return betr

def test_encoder_enable_disable():
    """测试编码器启用/禁用功能"""
    print("\nTesting Encoder Enable/Disable")
    betr = BETR_Encoder(sram_max_len=4, trace_filename="test_enable_disable_trace.txt")
    
    instr_stream = gen_instr_stream(normal_len=10, branch_len=2, trap_len=0, indirect_len=0)
    
    # 阶段1: 禁用状态
    print("Phase 1: Encoder Disabled")
    betr.set_enable(False)
    for i in range(3):
        betr.process_instr(instr_stream[i])
    
    # 阶段2: 启用状态
    print("Phase 2: Encoder Enabled")
    betr.set_enable(True)
    for i in range(3, 6):
        betr.process_instr(instr_stream[i])
    
    # 阶段3: 再次禁用
    print("Phase 3: Encoder Disabled Again")
    betr.set_enable(False)
    for i in range(6, 8):
        betr.process_instr(instr_stream[i])
    
    stats = betr.get_stats()
    print(f"Enable/disable test completed: {stats['total_missed']} instructions missed")
    return betr

def run_all_tests():
    """运行所有测试"""
    print("\n" + "=" * 70)
    print("BETR Encoder Test Suite")
    print("=" * 70)
    
    test_results = []
    test_functions = [
        test_basic_functionality,
        test_stop_address_feature, 
        test_sram_full_condition,
        test_encoder_enable_disable
    ]
    
    for test_func in test_functions:
        try:
            encoder = test_func()
            stats = encoder.get_stats()
            test_results.append({
                'test': test_func.__name__,
                'packets': stats['sram_packets'],
                'missed': stats['total_missed'],
                'status': 'PASS'
            })
        except Exception as e:
            test_results.append({
                'test': test_func.__name__, 
                'packets': 0,
                'missed': 0,
                'status': f'FAIL: {e}'
            })
    
    print("\n" + "=" * 70)
    print("Test Summary")
    print("=" * 70)
    for result in test_results:
        status_icon = "【STATUS】" if result['status'] == 'PASS' else "FAIL"
        print(f"{status_icon} {result['test']}: {result['status']}")
        print(f"   Packets: {result['packets']}, Missed: {result['missed']}")
    
    total = len(test_results)
    passed = sum(1 for r in test_results if r['status'] == 'PASS')
    print(f"\nTotal tests: {total}, Passed: {passed}, Failed: {total - passed}")


#####

## ===============================
## Example Usage
## ===============================
if __name__ == "__main__":
    print(f"\nTEST Finished.")
    
    #test_basic_functionality()

    # 方式：导入文件演示
    encoder = BETR_Encoder(sram_max_len=1000000,trace_filename="trace_signal_full.txt")
    encoder.trace_out.pkg_writer = TracePkgWriter("trace_pkg_only.txt")  # 保存纯包整数
    encoder.set_enable(True)
    
    #测试控制寄存器
    run_all_tests()
    
    #实际测试 Coremark-CALL+RET
    #encoder.import_and_process_log("../test/coremark/cva6_trace_log_for_test_CALL+RET.log")